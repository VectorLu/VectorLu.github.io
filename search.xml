<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[［置顶］博客地图]]></title>
      <url>%2F2020%2F01%2F10%2FblogIndex%2F</url>
      <content type="text"><![CDATA[默认分类不能充分展现博客的结构，而博客一般是按日期由近及远排放，很多东西不方便索引，置顶博客地图，方便读者了解我的知识结构，更方便按图索骥。 专业知识体系CS Basic我的外家功夫按最熟悉到相对最不熟悉，自上而下排列，会定期重新排序。 C／C++ 接近底层的高冷语言Python 不可不会的胶水语言Java 成熟的跨平台工业语言JavaScipt 立志要“一统天下”的语言Swift 苹果家正在成长的优秀开源语言Objective-C 苹果家的奇怪语言C# 微软家成熟的工业语言matlab 这个数学工具算语言吗shell 自动化工作必学语言php 世界上最好的语言？ 下面要列举出的，也是按最熟悉到相对最不熟悉，自上而下排列，但是严格意义上不属于编程语言，故出现了乖巧端庄如我的分割线。ˊ_&gt;ˋ HTML/CSS 标记语言和层叠样式LaTeX 排版系统XML 可扩展标记语言用来传输和存储数据。 JSON我的内功心法数据结构与算法 编译原理数据库系统原理 KIT工欲善其事，必先利其器。工具的使用就是“无他，唯手熟尔”，各种工具的使用笔记和技巧，希望能够提高学习、工作和生活的效率。 AIData一专多能的全栈之路Android开发的主攻方向，一起踏上 Android 甜品之旅吧：） iOS开发的次要学习方向。 DesignDevWeb百家争鸣，莫衷一是。 Hack不破不立。知道如何破局，方才知道如何更好地建立。 三省吾身专业纠错笔记和生活总结。 计算机专业相关编程通用一些代码踩坑 特别的关心给特别的你CCPPJava0 和 1 之外的大世界小生活江畔何人初见月，江月何年初照人？ 周月年]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法竞赛入门笔记]]></title>
      <url>%2F2017%2F01%2F24%2FAlgorithmCompetitionClassical0%2F</url>
      <content type="text"><![CDATA[《算法竞赛入门经典》——刘汝佳手写代码必备手册 的学习笔记整理 示例代码和习题代码下载 CH1 程序设计入门算法竞赛及面试编程提示 不要加上多余的提示和一些多余的 io 函数。 包括最后一行，每行以 \n 结束。除非有特殊说明。 只做三件事：读入数据，计算结果，打印输出。 尽量用 const 关键字声明常数。 酷爱在全局定义一个最大整数，例如 MAX，一般 OJ 题目都有数据规模的限制，所以定义一个常量 MAX 表示这个规模，可以不用动态分配内存。 经常使用全局变量。虽然工程上这样并不好。 不提倡防御式编程，不检查 malloc()/new 返回的指针是否为 NULL；不需要检查内部函数入口参数的有效性；使用纯 C 基于对象编程时，调用对象的成员方法，不需要检查对象自身是否为 NULL。 实验题环境mac, Xcode 无法得到理想结果的代码和实际输出样式1234567// 不报错，显示结果// nanprintf（“%f\n", sqrt(-10));// 不报错，显示结果// infprintf("%f\n", 1.0/0.0); 非法计算123456789101112131415#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; //no mistake printf("%f\n", 0.0/0.0); //no mistake, but warn //int isn't corresponded with double printf("%f\n", 0/0); //division by zero is undefined printf("%d\n", 0/0); return 0;&#125; 计算结果 nannan73823 12printf("%d\n", 1/0);printf("%d\n", 0/0); 1606416392 CH2 循环结构程序设计第二章完整代码 中国剩余定理题目要求：每组数据包含3个非负整数a,b,c，表示队尾人数（a&lt;3, b&lt;5, c&lt;7），输出总人数的最小值（或报告无解）。已知总人数不小于10，不超过100。输入到文件结束为止。我的这个解法为了简便，假设测试输入的a,b,c都满足条件，未对其进行合法判定。其实还应该加入对a, b , c对于3，5，7的大小判定才更加严密。 ChineseRemainderTheorem韩信点兵问题，又称中国剩余定理5和7的公倍数除以3余1的最小数是703和7的公倍数除以5余1的最小数是213和5的公倍数除以7余1的最小数是15总数除以3、5、7的余数分别设为a,b,c则sum = a70 + b21 + c*15再按范围减去105(3, 5, 7的最小公倍数) 完整代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; int a, b, c; int kase = 0; while(scanf("%d%d%d", &amp;a, &amp;b, &amp;c)==3) &#123; int sum = 0; sum = a*70 + b*21 + c*15; while(sum &gt; 100) &#123; sum -= 105; &#125; if(sum &lt; 10) &#123; printf("Case%d: No answer\n", kase); &#125; else &#123; printf("Case%d: %d\n", kase,sum); &#125; kase++; &#125; return 0;&#125; 子序列的和输入两个正整数 n&lt;m&lt;10^6, 输入 1/n^2+1/(n+1)^2+...+1/m^2，保留5位小数。输入包含多组数据，结束标记为n=m=0。样例输入：2 465536 6553600 0样例输出：Case1: 0.42361Case2: 0.00001 12345678910111213141516171819//主要在于m&lt;10^6，算法竞赛中的int类型范围大约是+-2*10^10，//所以i^2可能会超过int类型表示的范围，要用更大的类型来存储#include &lt;stdio.h&gt;int main()&#123; long n,m; int kase = 1; while(scanf("%ld%ld", &amp;n, &amp;m)==2 &amp;&amp; n &amp;&amp; m) &#123; double sum = 0; for(long i = n; i &lt;= m; i++) &#123; sum += (double)1/(i*i); &#125; printf("Case%d: %.5f\n", kase, sum); kase++; &#125; return 0;&#125; 分数化小数输入正整数a，b，c，输出a/b的小数形式，精确到小数点后c位。a，b&lt;=10^6，c&lt;=100。输入包含多组数据，结束标记为 a = b = c = 0。样例输入：1 6 40 0 0样例输出：Case1： 0.1667 1234567891011121314//关键在于小数部分的除法究竟是怎样除的//已经太习惯去除但是忘记了究竟是怎样的原理//就是把小数当做整数一样除，不过得到的商放在小数点之后void decimal(int a, int b, int c)&#123; printf("%d.", a/b); int rem = a%b; for(int i = 1; i &lt;= c; i++) &#123; rem *= 10; printf("%d", rem/b); rem = rem%b; &#125;&#125; 练习题：用1，2，3，…，9组成3个三位数abc,def和ghi，每个数字恰好使用一次，要求abc:def:ghi = 1:2:3。按照“abc def ghi”的格式输出所有解，每行一个解。提示：不必太动脑筋（既然题目说了不必太懂脑筋我就用了非常暴力的方法，见method2） 1234567891011121314151617181920212223242526272829303132333435363738//由1~9的和为45，9！= 362880判定是否互异//其实在不知道结果的前提下不够严谨//要学会熟练运用指针//method 1#include &lt;stdio.h&gt;void result(int num, int *result_add, int *result_multi)&#123; int a = num/100; int b = num/10%10; int c = num%10; *result_add += (a+b+c); *result_multi *= (a*b*c);&#125;int main()&#123; int result_add , result_multi; for(int abc = 100; abc &lt; 333; abc++) &#123; int def = 2*abc; int ghi = 3*abc; result_add = 0; result_multi = 1; result(abc, &amp;result_add, &amp;result_multi); result(def, &amp;result_add, &amp;result_multi); result(ghi, &amp;result_add, &amp;result_multi); //判断是否互异 if(result_add == 45 &amp;&amp; result_multi == 362880) &#123; printf("%d %d %d\n", abc, def, ghi); &#125; &#125; return 0;&#125; 以下是暴力求解法的片段。详见 暴力法求解的完整代码 1234567891011121314151617181920212223//method 2 片段 for(i = 1; i &lt; 10; i++) &#123; if(i == a)&#123;continue;&#125; if(i == b)&#123;continue;&#125; if(i == c)&#123;continue;&#125; if(i == d)&#123;continue;&#125; if(i == e)&#123;continue;&#125; if(i == f)&#123;continue;&#125; if(i == g)&#123;continue;&#125; if(i == h)&#123;continue;&#125; int abc = 100*a + 10*b + c; int def = 100*d + 10*e + f; int ghi = 100*g + 10*h + i; if(def == 2*abc &amp;&amp; ghi == 3*abc) &#123; printf("%d %d %d\n", abc, def, ghi); &#125; int main()&#123; permutation(); return 0;&#125; 实验 CH5 C++ 与 STL 入门从 C 到 C++编译命令gcc 主要用于编译 C 程序，C++ 程序要用 g++ 来编译。详细区别 常数定义声明数组时，数组大小可以使用 const 声明的常数（在 C99 中是不允许的）。在 C++ 中，更推荐用这种写法，而非使用 #define 声明常数。 布尔增加 bool 类型，用 true 和 false 来表示真假。虽然仍然可以用 int 来表示，但是 bool 类型的可读性更好。 引用在参数名之前加上一个 &amp; 符号，表示按引用传递，而不是 C 语言中按值传递。这样，在函数内改变参数的值，也会修改到函数的实参。 字符串可以把 string 作为流进行读写，#include&lt;sstream&gt;。虽然 string 和 sstream 都很方便，但是 string 很慢，sstream 更慢，应该谨慎使用。 结构体C++ 中的结构体除了可以有成员变量，还可以有成员函数。 C++ 中的结构体可以有一个或多个构造函数，在声明变量时调用。 C++ 中的函数（不只是构造函数）参数可以有默认值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python3 基础知识总结]]></title>
      <url>%2F2017%2F01%2F14%2FPython3Notes%2F</url>
      <content type="text"><![CDATA[Python3 学习笔记，主要记录一些 Python 中与别的语言不同的地方，需要注意的一些语法或快捷技巧。 流程控制布尔值任何非零整数都是 True，0 是 False。条件也可以是字符串或列表。所有长度不为 0 的是 True，空序列或空字符串是 False。 12&gt;&gt;&gt; bool(a)False 布尔操作符12345678910# 三个布尔操作符：and, or, not&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not not TrueTrue 优先级在所有算术和比较操作符求值后，Python 先求值 not操作符，然后是and 操作符，然后是 or 操作符。 not &gt; and &gt; or if 语句内置数据结构列表list.append(x)添加一个元素到列表的末尾。相当于 a[len(a):] = [x]。 list.extend(L)将给定列表L中的所有元素附加到原列表a的末尾。相当于 a[len(a):] = L。 list.insert(i, x)在给定位置插入一个元素。第一个参数为被插入元素的位置索引，因此 a.insert(0, x) 在列表头插入值， a.insert(len(a), x) 相当于 a.append(x). list.remove(x)删除列表中第一个值为 x 的元素。如果没有这样的元素将会报错 ValueError 。 list.pop([i])删除列表中给定位置的元素并返回它。如果没有给定位置，a.pop()将会删除并返回列表中的最后一个元素。（i 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示法)。 list.clear()删除列表中所有的元素。相当于 del a[:] 。 list.index(x)返回列表中第一个值为 x 的元素的索引。如果没有这样的元素将会报错。 list.count(x)返回列表中 x 出现的次数。 list.sort(key=None, reverse=False)排序列表中的项 (参数可被自定义, 参看 sorted() ). list.reverse()列表中的元素按位置反转。 list.copy()返回列表的一个浅拷贝。相当于 a[:]. 列表方法示例： 列表连接和复制123456&gt;&gt;&gt; [1, 2, 3] + ['A', 'B', 'C'][1, 2, 3, 'A', 'B', 'C']&gt;&gt;&gt; ['X', 'Y', 'Z'] * 3['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z'] &gt;&gt;&gt; spam = [1, 2, 3]&gt;&gt;&gt; spam = spam + ['A', 'B', 'C'] &gt;&gt;&gt; spam[1, 2, 3, 'A', 'B', 'C'] del 语句123456789101112131415&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a[1, 66.25, 333, 333, 1234.5]&gt;&gt;&gt; del a[2:4]&gt;&gt;&gt; a[1, 66.25, 1234.5]&gt;&gt;&gt; del a[:]&gt;&gt;&gt; a[]&gt;&gt;&gt; del a&gt;&gt;&gt; &gt;&gt;&gt; aTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'a' is not defined 类似列表的类型：字符串和元组列表是可变的，字符串和元组是不可变的。 字符串口令保管箱pyperclip 模块的安装1$ pip3 install pyperclip 杂print() 字符串转义如果不想让反斜杠 \ 及其后面的字符被当做转义字符，可以在第一个引号前加上 r，如下例： 1234567&gt;&gt;&gt; print('C:\some\\name')C:\some\name&gt;&gt;&gt; print('C:\some\name')C:\someame&gt;&gt;&gt; print(r'C:\some\name')C:\some\name 长字符串相邻的两个字符串文本自动连接在一起： 1234&gt;&gt;&gt; text = ('Put several strings within parentheses '... 'to have them joined together.')&gt;&gt;&gt; text'Put several strings within parentheses to have them joined together.' 或者用续行字符 \，将一条指令写成多行。 12print('Four score and seven ' + \ 'years ago ...')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017 年度书单]]></title>
      <url>%2F2017%2F01%2F11%2F2017BookList%2F</url>
      <content type="text"><![CDATA[2017 年的读书总结。 类时思读编程书不要边读书边做笔记，至少要读完一个完整的小节／章节／一本书再来做笔记。否则有以下缺陷： 容易走神，然后就开始不动脑筋地抄书，这样浪费时间而且没有效果 进度非常慢，容易在细枝末节上花费太多时间，想想年少无知时读谭浩强的《C 语言程序设计》的惨痛经历，呵呵。 但是也不能完全不做笔记，如果不做笔记，说不定 下次还是会栽在这个坑里！ 忘记了从哪里做起，又得从头开始，摔！ 那么应该怎样做笔记呢？应该在什么时机、对什么样的内容做笔记呢？ 记录书上容易忘记，需要用到，而且不易搜索的知识。读完一个完整的小节／章节／一本书，实现并保存了重要的代码后，将本来不太清楚的代码实现思路、容易和其他语言混淆的地方记下来。 记录花费了一些时间，才弄懂的知识。谨慎思考所得。在读书过程中，会遇到一些比较难的内容，特别是一些比较难的算法思想、算法实现过程，一些比较 tricky 的代码实现细节，在读的时候，一开始有些想不通，花费了一些时间才明白的内容，应该努力做好笔记，写下为什么要这样做的，自己的，详细的思考过程。 很有可能想了好久还是没有弄懂，需要求助于网络和各位前辈的， 需要暂时跳过，等积累了一些实践经验再回来思考的 欢0123发现了一个网站]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手写一个 C 语言编译器]]></title>
      <url>%2F2016%2F12%2F25%2FSimpleCompilerByC%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AlgorithmNotice]]></title>
      <url>%2F2016%2F12%2F23%2FAlgorithmNotice%2F</url>
      <content type="text"><![CDATA[算法问题中需要注意些什么呢？ 0 输入与输出在写算法时，一定要充分考虑到输入数据的特征、可能存在的问题，还有是否需要保存数据。不要天真地以为输入一定是某种特定的数据类型，大小排列方式…… 然后尽量对数据做一些预处理，以免在程序运行中造成一些破坏，举个很简单的例子——求最大公约数和最小公倍数，为了防止第二个输入的数大于第一个数，做了一个判断和交换： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main()&#123; int max, min; int copy1, copy2; int temp; printf("请输入两个正整数：\n"); scanf("%d %d", &amp;max, &amp;min); copy1 = max; copy2 = min; // 如果 min &gt; max // 互换 if (min &gt; max) &#123; temp = min; min = max; max = temp; &#125; while (min != 0) &#123; temp = min; min = max % min; max = temp; &#125; printf("它们的最大公约数为：%d\n", max); printf("它们的最小公倍数为：%d\n", copy1*copy2/max); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言中的输入／输出]]></title>
      <url>%2F2016%2F12%2F20%2FioOfC%2F</url>
      <content type="text"><![CDATA[任意输入的源或任意输出的目的地叫做流。 流文件指针C 程序中对流的访问是通过 文件指针 来实现的，如果程序除了标准流之外还需要两个流，可以包含如下声明： 1FILE *fp1, *fp2; 该结构（类型）在 中，大概的定义，不同的实现可能有所 不同 1234567891011typedef struct _iobuf&#123; char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname;&#125;FILE; 注意到了这个结构体的 tag 了吗——_iobuf，定义了文件的缓冲区大小、缓冲区位置、访问模式、文件描述等信息。 标准流和重定向可以直接使用的 3 个标准流：stdin, stdout, stderr 。 输入重定向1demo &lt;in.dat 输出重定向1demo &gt;out.dat 总结把符号看成一个漏斗，大的是起点，小的是终点。 1234demo &lt; in.dat &gt; out.datdemo &gt; out.dat &lt; in.dat// 文件顺序无关紧要，以上效果一样// &gt; &lt; 不需要于文件名相邻 文本文件与二进制文件文本文件字节表示字符。 文本文件分为若干行。每一行通常以一两个特殊字符结尾。Windows 中，是回车和紧跟其后的换行符，分别为 &#39;\x0d&#39;, &#39;\x0a&#39; 在 类 UNIX 系统中，行末是单独的回行符，旧版 Mac OS 使用单独的回车符。 包含特殊的“文件末尾”标记。在 Windows 中，标记为 &#39;\x1a&#39;(Ctrl+Z) 二进制文件编写用来读写文件的程序时，需要考虑该文件是文本文件还是二进制文件。 在屏幕上显示文件内容的程序可能要把文件视为文本文件。但是，文件复制程序就不能认为要复制的文件为文本文件。 如果那样做，就不能完全复制含有文件末尾字符的文本文件。在无法确定文件是文本形式还是二进制形式时，安全的做法是把文件假定为二进制文件。 文件操作打开文件Windows 中不要使用绝对路径分隔符 \ （会被认为是转义字符），使用相对路径分隔符 / 1fopen("c:/project/test1.dat", "r"); 永远不要假设每次都能打开文件，每次都必须要测试 fopen 函数的返回值以确保不是空指针。 模式用于文本文件的模式字符串 模式字符串 含义 “r” 打开文件用于读 “w” 打开文件用于写（文件不需要存在） “a” 打开文件用于追加（文件不需要存在） “r+” 打开文件用于读和写，从文件头开始 “w+” 打开文件用于读和写，如果文件存在就截去 “a+” 打开文件用于读和写（如果文件存在就追加） 二进制文件与之类似，但是需要在模式字符串中包含字母 b，例如 &quot;rb&quot; 关闭文件fclose() 关闭不再使用的文件，参数是文件指针。如果成功关闭了文件，函数返回零，否则返回错误代码 EOF。对文件的输入／输出操作都是在缓冲区中进行的，写入文件的数据可能还没有真正地写到磁盘中，而是在内存的缓冲区中，如果不执行关闭文件操作，可能会使部分数据未保存到文件中。 1int fcloseall(void); 示例12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILE_NAME "example.dat"int main(void)&#123; FILE *fp; fp = fopen(FILE_NAME, "r"); if (fp == NULL) &#123; printf("Can't open %s\n", FILE_NAME); exit(EXIT_FAILURE); &#125; ... fclose(fp); return 0;&#125; 当然，也可以： 1if ((fp = fopen(FILE_NAME, "r")) == NULL) ... 从命令行获取文件名123456789101112131415161718192021222324// checks whether a file can be opened for reading#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; FILE *fp; if (argc != 2) &#123; printf("usage: canopen filename\n"); exit(EXIT_FAILURE); &#125; if ((fp = fopen(argv[1],"r"))==NULL) &#123; printf("%s can't be opened\n", argv[1]); exit(EXIT_FAILURE); &#125; printf("%s can be opened\n", argv[1]); fclose(fp); return 0;&#125; 临时文件12FILE *tmpfile(void);char *tmpnam(char *s); 不要过于频繁地调用 tmpnam() 。 文件缓冲123int fflush(FILE *stream);void setbuf(FILE * restrict stream, char * restrict buf);int setvbuf(FILE * restrict stream, char * restrict buf, int mode, size_t size); 其他文件操作12int remove(const char *filename);int rename(const char *old, const char *new); 以上两个函数对文件名而不是文件指针进行处理，如果调用成功，这两个函数都返回零；否则，都返回非零值。 123remove("foo.txt"); // delete the file named "foo.txt"rename("foo.txt", "bar.txt"); 如果打开了要改名的文件，那么一定要保证在调用 rename() 之前关闭此文件。对打开的文件执行改名操作会失败。 格式化输入／输出12345678// writes to fpfprintf(fp, "Total: %d\n", total);// fprintf() 可以用于任何输出流// 最常用于fprintf(stderr, "Error: date file can't be opened.\n");fsanf(fp, "%d%d", &amp;i, &amp;j); 在 C 程序中测试 scanf() 的返回值的循环很普遍，如下，在首个遇到问题的符号处停止： 1234while(scanf("%d", &amp;i) == 1)&#123; ...&#125; …scanf 格式串 转换说明。大多数转换说明 (%c, %n 例外 ) 会跳过输入项开始处的空白字符。但是，转换说明不会跳过尾部的空白字符。但是，转换说明不会跳过尾部的空白字符。 空白字符。该中函数格式串中的一个或多个连续的空白字符与输入流中的零个或多个空白字符相匹配。 字符的输入／输出12345678910111213int fputc(int c, FILE *stream);int putc(int c, FILE *stream);int putchar(int c); // 向标准输出流 stdout 写一个字符putchar(ch);fputc(ch, fp); // 函数实现，速度较 putc() 慢putc(ch, fp); // 宏，也有函数实现int fgetc(FILE *stream);int getc(FILE *stream);int getchar(void); // 从标准输入流 stdin 中读入一个字符 进行文件的复制操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 编译：gcc -o fcopy fcopy.c // 命令：fcopy f1.c f2.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[])&#123; FILE *sourceFp, *destFp; int ch; if (argc != 3) &#123; fprintf(stderr, "usage: fcopy source dest\n"); exit(EXIT_FAILURE); &#125; // 采用 "rb" 和 "wb" 作为文件模式 // 既可以复制文本文件，又可以复制二进制文件 // 如果是用 "r" 和 "w" 来代替 // 那么程序将无法复制二进制文件 if ((sourceFp = fopen(argv[1], "rb")) == NULL) &#123; fprintf(stderr, "Can't open %s\n", argv[1]); exit(EXIT_FAILURE); &#125; if ((sourceFp = fopen(argv[2], "wb")) == NULL) &#123; fprintf(stderr, "Can't open %s\n", argv[2]); fclose(sourceFp); exit(EXIT_FAILURE); &#125; while((ch=getc(sourceFp)) != EOF) &#123; putc(ch, destFp); &#125; fclose(sourceFp); fclose(destFp); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sortAlgorithm]]></title>
      <url>%2F2016%2F12%2F19%2FsortAlgorithm%2F</url>
      <content type="text"><![CDATA[排序算法的总结和 C 语言实现 选择排序选择最小的元素，放在最前面。然后在剩下的元素中选择最小的，放在第 0 个元素的后面，依此类推，剩下最后一个自然成序，算法核心代码： 123456789101112// 选择排序 for (i = 0; i &lt; 9; i++) &#123; min = i; for (j = i; j &lt; 10; j++) &#123; if (array[min] &gt; array[j])&#123;min = j;&#125; &#125; temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; 完整的可运行代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int main()&#123; int i, j, min, temp; // 定义一个整形的一维数组 int array[10]; // 输入数据 printf("Please input ten integer: \n"); for (i = 0; i &lt; 10; i++) &#123; printf("array[%d] = ", i); scanf("%d", &amp;array[i]); &#125; printf("The array is: "); for (i = 0; i &lt; 10; i++) &#123; printf("%d ", array[i]); &#125; printf("\n"); // 选择排序 for (i = 0; i &lt; 9; i++) &#123; min = i; for (j = i; j &lt; 10; j++) &#123; if (array[min] &gt; array[j])&#123;min = j;&#125; &#125; temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; // 输出 printf("\nThe result: \n"); for ( i = 0; i &lt; 10; i++) &#123; printf("%d ", array[i]); &#125; printf("\n"); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[遗传算法初探]]></title>
      <url>%2F2016%2F12%2F18%2FnewToGeneticAlgorithm%2F</url>
      <content type="text"><![CDATA[遗传算法——听上去颇为神秘有趣，那么遗传算法究竟是什么呢？应该如何用代码实现这一算法呢？ 遗传算法理论简介基本概念 基因：组成染色体的单元，可以表示为一个二进制位，一个整数或一个字符等。 染色体：表示待求解问题的一个可能解，由若干基因组成，是 GA 操作的基本对象。 个体：在本节中个体等同于染色体，从基因角度而言称为染色体，从适应度函数角度称为个体。 群体：一定数量的染色体组成了群体，表示 GA 的遗传搜索空间。 适应度：代表一个染色体所对应解的优劣，通常由某一适应度函数表示。 基本操作： 选择：根据个体的适应度，在群体中按照一定的概率选择可以作为父本的个体，选择依据是适应度大的个体被选中的概率高。选择操作体现了适者生存、优胜劣汰的进化规则。 交叉：将父本染色体的基因按照一定概率随机地交换，形成新的染色体。 变异：按一定的概率改变染色体内的某个基因值。 主要处理步骤： 对优化问题的解进行编码，即用染色体表示优化问题的可能解，组成染色体的元素称为基因。 适应度函数的构造和应用——因优化问题的目标函数而定。 以各染色体所对应的适应度函数值的大小决定哪些染色体适应生存，哪些被淘汰。 生存下来的染色体组成种群，形成一个可以繁衍下一代的群体。双亲遗传的结合通过编码之间的交叉 crossover 实现下一代的产生。新的染色体产生时，以一定概率发生基因变异，变异使解有更大的遍历性，防止过早收敛于局部极小值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[结构、联合和枚举]]></title>
      <url>%2F2016%2F12%2F18%2FstructOfC%2F</url>
      <content type="text"><![CDATA[函数延迟绑定；数据结构导致绑定。记住：在编程过程后期再结构化数据。 声明时：struct 和 union 的每个成员用分号隔开，enum 的每个成员用逗号隔开。 结构变量每个结构都为它的成员设置了独立的 name space。 将点号和成员名称的组合称为指示符，可用指示符进行指定初始化 (C99)： 12345struct &#123; int number; char name[NAME_LEN+1]; int on, hand;&#125; part1 = &#123;.number = 528, .name = "Disk drive", .on_hand = 10&#125;; 句点运算符的优先级和后缀 ++-- 一样，所以优先级几乎高于其他所有运算符。 结构可以用 = 运算符进行复制（仅用于类型兼容的结构），而且对结构复制时，嵌在结构里的数组也得到了复制。可以利用这种性质来产生“空结构”，已封装稍候将进行复制的数组： 12struct &#123; int a[10]; &#125; a1, a2;a1 = a2; 但是除了赋值运算，C 语言没有提供其他用于整个结构的操作。特别是不能使用运算符 == 和 != 来判定两个结构相等还是不等。 联合用联合来节省空间假设礼品册上只有三种商品：书籍、被子和衬衫，每种商品都含有库存量、价格一级与商品类型相关的其他信息： 书籍：书名、作者、页数。 杯子：设计。 衬衫：设计、可选颜色、可选尺寸。 最初的设计可能会得到如下结构： 1234567891011struct catalog_item&#123; int stock_number; float price; int item_type; char title[TITLE_LEN+1]; char author[AUTHOR_LEN+1]; int num_pages; char design[DESIGN_LEN+1]; int colors; int sizes;&#125;; 虽然上述结构十分好用，但是很浪费空间，因为只有结构中的部分信息是常用的。 1234567891011121314151617181920struct catalog_item&#123; int stock_number; float price; int item_type; union&#123; struct&#123; char title[TITLE_LEN+1]; char author[AUTHOR_LEN+1]; int num_pages; &#125; book; struct&#123; char design[DESIGN_LEN+1]; &#125; mug; struct&#123; char design[DESIGN_LEN+1]; int colors; int sizes; &#125; shirt; &#125; item;&#125;; 如果 c 是表示书籍的结构 catalog_item，那么刻意用下列方法显示书籍的名称： 1printf("%s", c.item.book.title); 用联合来构造混合的数据结构假设需要数组的元素是 int 值和 double 值的混合，因为数组的元素必须是相同的类型，所以要利用联合。 123456789typedef union&#123; int i; double d;&#125; Number;Number number_array[1000];number_array[0].i = 5;number_array[1].f = 8.295; 为联合添加“标记字段”如果： 123456void print_number(Number n)&#123; if (n 包含一个整数) &#123;printf("%d", n.i);&#125; else &#123;printf("%g", n.d);&#125;&#125; 但是，没有办法可以帮助函数确定 n 包含到是整数还是浮点数。 为了记录此信息，可以把联合嵌入一个结构中，且此结构还含有另一个成员：“标记字段”，它是用来提示当前存储在联合中的内容的。 比如之前讨论的结构 catalog_item 中的 item_type 就是用于该目的。 12345678910#define INT_KIND 0#define DOUBLE_KIND 1typedef struct&#123; int kind; // tag field union&#123; int i; double d; &#125; u;&#125; Number; Number 有两个成员 kind 和 u，kind 的值可能是 INT_KIND 或 DOUBLE_KIND 每次给 u 的成员赋值时，也会改变 kind，从而提示修改的是 u 的哪个成员。 1234567891011Number n;n.kind = INT_KIND;n.u.i = 82;void print_number(Number n)&#123; if (n.kind == INT_KIND) &#123;printf("%d", n.u.i);&#125; else &#123;printf("%g", n.u.d);&#125;&#125; 枚举枚举是整数，值（默认）从 0 开始逐渐增加，所以是很理想的下标。在 C89 中，利用 typedef 来命名枚举是创建布尔类型的一种非常好的方法： 1234typedef enum &#123;FALSE, TRUE&#125; Bool;enum suit &#123;CLUSBS, DIAMONDS, HEARTS, SPADES&#125;;typedef enum &#123;CLUBS, DIAMONDS, HEARTS, SPADES) Suit; 枚举作为整数1enum suit &#123;CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4&#125;; 允许与普通整数混合使用。 用枚举声明“标记字段”1234567typedef struct&#123; enum (INT_KIND, DOUBLE_KIND) kind; union &#123; int i; double d; &#125; u;&#125; Number;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言预处理器]]></title>
      <url>%2F2016%2F12%2F17%2FpreprocessorOfC%2F</url>
      <content type="text"><![CDATA[C 处理器可以是强大的工具，也可以成为不易发现的错误之源。 预处理器 用 gcc -E program.c 就能看到预处理器的输出 预处理器仅知道很少的 C 语言规则 所以很容易出现错误 对于复杂的程序， 检查预处理器的输出是找到这类错误的很好的办法 预处理器指令大多数预处理指令属于下面 3 种类型之一： 宏定义。#define 定义一个宏，#undef 删除一个宏定义。 文件包含。#include 条件编译。#if, #ifdef, #ifndef, #elif 和 #endif 指令可以让预处理器以测试的条件来确定是否将一段文本段包含到程序中。 剩下 #error, #line, #pragma 较少用到。 注意 指令都以 # 开头 指令总是在第一个换行符处结束，除非明确地指明要延续——在行末使用 \。例如，下面的指令定义了一个宏来表示硬盘的容量（按字节算）： 1234#define DISK_CAPACITY(SIDES * \ TRACKS_PER_SIDE * \ SECTORS_PER_TRACK * \ BYTES_PER_SECTOR) 指令可以出程序中的任何地方，甚至函数定义的中间。但是我们通常将 #define 和 #include 指令放在文件的开始。 注释可以与指令放在同一行。 宏定义不需要使用等号1234// 样式：// #define 标识符 替换列表#define STR_LEN 80 对 C 语言做小的修改虽然这通常不是个好主意。比如： 1234#define BEGIN &#123;#define END &#125;#define LOOP for(; ; ) 对类型重命名1#define BOOL int 带参数的宏12345678// 格式：// #define 标识符(x1, x2, ..., xn) 替换列表// x1-xn 是宏的参数// 在宏的名字和左括号间必须没有空格#define MAX(x, y) ((x)&gt;(y)?(x):(y))#define IS_EVEN(n) ((n)%2 == 0)#define IS_ODD(n) ((n)%2 != 0) 如果后面的程序中有如下语句： 12i = MAX(j+k, m-n);if (IS_EVEN(i))&#123;i++;&#125; 预处理器会将这些行替换为： 12i = ((j+k)&gt;(m-n)?(j+k):(m-n));if (((i)%2==0)) &#123;i++;&#125; 使用带参数的宏替代真正的函数有两个优点： 程序可能稍微快些。程序执行时调用函数通常会有些额外开销——存储上下文信息、复制参数的值等，而调用宏则没有这些运行开销。（C99 中的内联函数为我们提供了不使用宏而避免这一开销的办法。） 宏更“通用”。与函数的参数不同，宏的参数没有类型。只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。如上例，可以用 MAX 宏来选出较大的一个。数的类型可以是 int, long, float, double 等。 编译后的代码通常会变大。宏的使用越频繁，效果越明显。 宏参数没有类型检查。预处理器不会检查宏参数的类型，也不回进行类型转换。 无法用指针指向一个宏。 宏可能会不止一次地计算它的参数。为了自我保护，最好避免使用带有副作用的参数。函数对它的参数只会计算一次，而宏可能会计算两次甚至更多次。如果参数有副作用： 12n = MAX(i++, j);// n = ((i++)&gt;(j)?(i++):(j)); 带参数的宏不仅适用于模拟函数调用，还经常用作需要重复书写的代码段模式。例如： 1#define PRINT_INT(n) printf("%d\n", n) # 运算符将宏的一个参数转换为字符串字面量。 12345#define PRINT_INT(n) printf(#n " = %d\n", n)PRINT_INT(i/j);// printf("i/j = %d\n", i/j);// i/j = 5 ## 运算符使两个记号（如标识符）“粘合”在一起 12345#define MK_ID(n) i##nint MK_ID(1), MK_ID(2), MK_ID(3);// 预处理后// int i1, i2, i3; 一个更实用的例子： 12345#define GENERIC_MAX(type) \type type##_max(type x, type y) \&#123; \ return x &gt; y ? x : y; \&#125; 如果需要一个针对 float 值的 max()。下面是使用 GENERIC_MAX 宏来定义这一函数的方法： 1234GENERIC_MAX(float)// 预处理将其展开为：// float float_max(float x, float y) &#123; return x &gt; y ? x : y;&#125; 宏的通用属性替换列表可以包含对其他宏的调用12#define PI 3.14159#define TWO_PI (2*PI) 预处理器会不断重新检查替换列表，直到所有的宏名字都替换掉为止。 只替换完整的记号预处理器会忽略前在标识符、字符常量、字符串字面量值之中的宏名。 宏不可以被定义两遍除非新旧定义一样 用 #undef 取消定义#undef N 会删除宏 N 当前的定义。（如果 N 没有被定义成一个宏，#undef 指令没有任何作用。） 宏定义中的括号 如果有运算符，始终将替换列表放在括号中：#define TWO_PI (2*3.14159) 如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中：#define SCALE(x) ((x)*10) 如果没有括号，编译器可能会不按我们期望的方式应用运算符的优先级和结合性规则。 预定义宏用 __DATE__ 宏和 __TIME__ 宏指明程序编译的时间。来帮助区分同一程序的不同版本。 12printf("Wacky Windows (c) 2010 Wacky Software, Inc.\n");printf(Compiled on %s at %s\n", __DATE__, __TIME__); 可以使用 __LINE__ 宏和 __FILE__ 宏来找到错误。考虑被零除的定位问题。当 C 程序因为被零除而导致终止时，通常没有信息指明哪条除法导致错误。下面的宏可以帮助我们查明错误的根源： 1234#define CHECK_ZERO(divisor) \ if (divisor == 0) \ printf("*** Attempt to divide by zero on line %d " \ "of file %s ***\n", __LINE__, __FILE__) __func__ 标识符每一个函数都可以访问 __func 标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量。其作用相当于在函数体的一开始包含如下声明： 1static const char __func__[] = "function-name"; 其中 function-name 是函数名。这个标识符的存在使得我们可以写出如下的调试宏： 12#define FUNCTION_CALLED() printf("%s called\n", __func__);#define FUNCTION_RETURNS() printf("%s returns\n", __func__); 对这些宏的调用可以放在函数体中，以跟踪函数的调用： 123456void f(void)&#123; FUNCTION_CALLED(); ... FUNCTION_RETURNS();&#125; __func__ 另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。 条件编译#if and #endif1234#define DEBUG 1#if DEBUG...#endif defined如果标识符是一个定义过的宏则返回 1，否则返回 0 123#if defined DEBUG...#endif 和下面这段等价： 123#ifdef 标识符当标识符被定义为宏时需要包含的代码#endif #elif and #else使用条件编译条件编译用于调试是非常方便的，但是其应用不限于此。 在多台机器或多种操作系统之间可移植的程序下面的例子中会根据 WIN32, MAC_OS 或 LINUX 是否被定义为宏，而将三组代码之一包含到程序中： 1234567#if defined(WIN32)...#elif defined(MAC_OS)...#elif defined(LINUX)...#endif 可以用不同编译器编译的程序为宏提供默认定义123#ifndef BUFFER_SIZE#define BUFFER_SIZE 256#endif 条件屏蔽123#if 0包含注释的代码行#endif 其他指令#error 指令通常与条件编译指令一起监测正常编译过程中不应该出现的情况，往往预示着程序中出现了严重的错误。 123#if INT_MAX &lt; 100000#error int type is too small#endif 如果试图在一台以 16 位存储整数的机器上编译这个程序，将产生一条出错消息： Error directive: int type is too small #error 指令通常会出现在 #if-#elif-#else 中的最后一部分： 123456789#if defined(WIN32)...#elif defined(MAC_OS)...#elif defined(LINUX)...#else#error No operating system specified#endif FAQ究竟哪些常量需要定义成宏？ 除了 0 和 1 以外的每一个数值常量都应该定义成宏。使用宏来替换字符或字符串常量并不总能够提高程序的可读性，建议是：当常量被不止一次地使用，或以后可能需要修改常量时使用。 在执行预处理指令前，先处理注释。如果使用了条件屏蔽，而 #if 和 #endif 之间有未终止的注释，会引起错误。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言中的字符串详解]]></title>
      <url>%2F2016%2F12%2F16%2FCString%2F</url>
      <content type="text"><![CDATA[C 语言没有专门的字符串类型，要如何对字符串进行操作呢？其中又有哪些陷阱呢？ 字符串字面量123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;// 把字符串当作数组的操作char digit_to_hex_char(int digit)&#123; // 把 0-15 的数转换成等价的 16 进制数 return "012345689ABCDEF"[digit];&#125;int main(void)&#123; /* * 字符串拼接 * 当两个或更多个字符串相邻时 * 仅用空白字符分割（不用逗号） * 编译器会把它们合并成一个字符串 * 执行结果： * hen you come to a fork in the road, take it. --Yogi Berra */ printf("When you come to a fork in the road, " "take it. " "--Yogi Berra\n"); printf("%c\n", digit_to_hex_char(12)); return 0;&#125; 注意不能改变字符串字面量的值，如下程序执行时产生错误 Bus error: 10。字符串字面量可能存在只读的区域。 123456789#include &lt;stdio.h&gt;int main(void)&#123; char *p = "abc"; *p = 'd'; return 0;&#125; 字符串变量C 中，只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。有时很难辨别是否把字符数组作为字符串来使用。 123456789101112131415161718192021#include &lt;stdio.h&gt;// 惯用的字符串声明方法#define STR_LEN 80char str[STR_LEN+1];int main(void)&#123; /* * 下面是两种相似的声明，均可作为字符串 * 但是两者不能互换 * 1. 声明为数组时，就像任意数组中的元素，可以修改 dateArray 中 * 的字符，dateArray 是数组名。 * 2. 声明为指针时，datePtr 指向字符串字面量， * 字符串字面量是不可以修改的，datePtr 是变量， * 可以在程序执行期间指向其他字符串。 * 如果希望可以修改字符串，那么就要建立字符数组来存储字符串 */ char dateArray[] = "June 14"; char *datePtr = "June 14"; return 0;&#125; 另外，注意使用指针作为字符串变量之前必须把指针指向字符数组。或者让指针指向一个动态分配的字符串。 如果指针没有初始化，我们不知道它指向哪里，将其作为字符串时非常严重的错误。 123456char *p;/*****WRONG******/p[0] = 'a';p[1] = 'b';p[2] = '\0'; 字符串的读写换行符、空格符或制表符等会使 scanf() 停止读入，用 scanf() 读入的字符串永远不会包含空白字符。 123456789101112131415161718#include &lt;stdio.h&gt;int main(void)&#123; char str[10]; scanf("%s", str); printf("%s\n\n", str); return 0;&#125;/* 执行结果bash-3.2$ gcc basic.cbash-3.2$ ./a.outhi strhibash-3.2$*/ 设计自己的输入函数考虑如下问题： 在开始存储字符串之前，函数应该跳过空白字符吗？ 什么字符会导致函数停止读取：换行符、任意空白字符还是其他某种字符？需要存储这类字符还是忽略掉？ 如果输入的字符串太长以致无法存储，那么函数应该做些什么：忽略额外的字符还是把它们留给下一次输入操作？ 注意手动加上 &#39;\0&#39;。 123456789101112int read_line(char str[], int n)&#123; int ch, i = 0; while((ch=getchar())!='\n' &amp;&amp; ch!=EOF) &#123; if (i &lt; n) &#123;str[i++] = ch;&#125; &#125; str[i] = '\0'; return i;&#125; 使用 C 语言的字符串库strcpy()在 &lt;string.h&gt; 中的原型如下： 1char *strcpy(char* s1, const char * s2); 函数把 s2 指向的字符串复制到 s1 指向的数组中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 C 语言编写大型程序]]></title>
      <url>%2F2016%2F12%2F15%2FmultipleCFiles%2F</url>
      <content type="text"><![CDATA[C 语言不是为开发大型程序设计的，但是有很多的大型程序都是用 C 语言写的。 头文件include12345678910111213#include &lt;header.h&gt; // 用于属于 C 语言自身库的头文件#include "myHeader.h" // 自己编写的头文件/******** 用宏来定义文件名 ************/#if defined(IA32) #define CPU_FILE "ia32.h"#elif defined(IA64) #define CPU_FILE "ia64.h"#elif defined(AMD64) #define CPU_FILE "amd64.h"#endif#include CPU_FILE 为了防止文件多次包含，用 ifndef 和 #endif 指令来封闭文件的内容。 12345678#ifndef BOOLEAN_H#define BOOLEAN_H#define TRUE 1#define FALSE 0typedef int Bool;#endif #error 指令如果头文件中用到了一个在最初的 C89 标准之前不存在的特性，为了避免把头文件用于旧的非标准编译器，可以在头文件中包含 #ifdef 指令来检查 __STDC__ 宏是否存在： 123#ifndef __STDC__#error This header requires a Standard C compiler#endif 构建多文件程序1gcc -o justify justify.c line.c word.c makefile]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言指针总结]]></title>
      <url>%2F2016%2F12%2F14%2FPointersOnC%2F</url>
      <content type="text"><![CDATA[指针是 C 语言的魅力所在，也是陷阱所在。 疑惑：取址符在声明和语句中我在学习指针的时候，觉得声明 int *p = &amp;i; 和语句 p = &amp;i; 不一致。相信很多人也有同样的疑惑。 造成困惑的根源在于，根据使用上下文的不同，C 语言中的 * 号可以有多种含义。 在声明 int *p = &amp;i; 中，* 号不是间接寻址运算符，其作用是告知编译器 p 是一个指向 int 类型变量的指针。 而在语句中出现时，* 号（作为一元运算符使用时）会执行间接寻址。 打印任何指针使用转换说明符 %p 来显示。 数组可以把指针指向数组元素。 1234int a[10];int *p;p = &amp;a[0];*p = 5; 通过在 p 上执行指针算术运算（或者地址算术运算）可以访问数组 a 的其他所有元素。C 语言支持 3 种格式的指针算术运算： 指针 + 整数 指针 - 整数 两个指针相减（只有在两个指针指向同一个数组时，把它们相减才有意义） 指向同一数组的指针可以用关系运算符进行比较。 虽然可以把数组名 int a[10] 用作指针，但是不能给数组名赋新的值。试图使数组名指向其他地方是错误的。 1234while (*a != 0)&#123; a++; // WRONG&#125; 可以将 a 复制给一个指针变量，然后改变该指针变量。 123p = a;while (*p != 0)&#123;p++;&#125; 指针与地址指针通常是地址，但是指针不是真正的内存地址，CPU 必须把它和存储在专用寄存器中的段值结合起来，来表示“偏移量”。 const 与指针当某个函数使用指针时，可能只是为了检查其中的某个值，而不改变它。可以用 const 保护参数。 1234void f(const int *p)&#123; *p = 0; // WRONG&#125; 这一用法表明 p 是指向“常整数”的指针。试图改变 *p 是编译器会检查的一种错误。 再来仔细学习一下 const。 12int const a;const int a; 两种方式一样，a 的值无法修改，要让它一开始就拥有一个值 声明时初始化 int const a = 1; 在函数中声明为 const 的形参在函数被调用的时候会获得实参的值 然而 const 和 指针一起使用时——有两样东西有可能成为常量——指针变量和它指向的实体，示例（这里是《C和指针》里的实例，变量名取得非常有意义） 12345678910111213141516171819202122//pi是一个普通的指向整型的指针int *pi; /* ** pci 是一个指向整型常量的指针** 怎样理解？** 理解为对pci进行间接访问操作后得到的是一个整型常量** 是不是超简单** 可以修改指针的值，但是不能修改它指向的整型数*/int const *pci;/*** 指向整型的常量指针** 指针是常量，无法修改，但是可以修改它指向的值** 理解为对某个常量进行间接访问得到的是一个整型** 而这个常量是一个指向整型的指针*/int * const cpi;/*** 指针本身和它指向的变量都不允许修改*/int const * const cpci; 为了指明数组型形式参数不会被改变，可以在其声明中包含单词 const： 1234int findLargest(const int a[], int n)&#123; ...&#125; 主要是看 const 右边是什么。 指针作为返回值可以作为函数的返回值。但是永远不要返回指向自动局部变量的指针： 123456int *f(void)&#123; int i; ... return &amp;i;&#125; 一旦 f() 返回，变量 i 就不存在了，所以指向变量 i 的指针将是无效的。有的编译器会在这种情况下给出类似 “function returns address of local variable” 的警告。 动态存储分配内存分配函数为了动态地分配存储空间，需要调用三种内存分配函数的一种，这些函数都是声明在 &lt;stdlib.h&gt; 头中的。 malloc() ——分配内存块，但是不对内存进行初始化。 calloc() ——分配内存块，并且对内存块进行清零。 realloc() ——调整先前分配的内存块大小。 当为申请内存块而调用内存分配函数时，由于函数无法知道存储在内存块中的数据是什么类型的，所以它不能返回 int 类型、char 类型等普通类型的指针。取而代之的，函数会返回 void * 类型的值，void * 类型的值是“通用”指针，本质上它只是内存地址。 空指针当调用内存分配函数时，如果找不到满足需要的内存块，函数会返回空指针。把函数的返回值存储到指针变量中以后，需要判断该指针变量是否为空指针。如果为空，需要采取适当的动作。 所有非空指针都为真，只有空指针为假。 12345if (!p)// if (p == NULL)if (p)// if (p != NULL) 与 NULL 进行比较可读性更好 动态分配字符串使用 malloc() 为字符串分配内存函数原型： 1void *malloc(size_t size); size_t 表示某块内存的大小，取值范围是目标平台下最大可能的数组尺寸。 1reminds[i] = (char *)malloc(2+strlen(msg_str)+1); 使用 calloc()1void *calloc(size_t nmemb, size_t size); calloc() 函数会将内存初始化为 0（清除分配的内存） 12struct point &#123;int x; int y;&#125; *p;p = calloc (1, sizeof (struct point)); 使用 realloc()1void *realloc(void *ptr, size_t size); 要确定传递给 realloc 函数的指针来自于先前 malloc, calloc 或 realloc 的调用。否则，程序可能行为异常。 当扩展内存块时，realloc() 不回对添加进内存块的字节进行初始化。 如果 realloc() 不能按要求扩大内存块，那么它会返回空指针，并且在原有内存块中的数据不会改变。 如果 realloc() 被调用时以 0 作为第二个实际参数，那么它会释放掉内存块。 一旦 realloc 函数返回，一定要对指向内存块的所有指针进行更新，因为 realloc 函数可能会使内存块移动到了其他地方。 释放存储空间对于程序而言，不可再访问到的内存块被称为是垃圾 (garbage)。 free()1void free(void *ptr); 要确定传递给 realloc 函数的指针来自于先前 malloc, calloc 或 realloc 的调用。否则，程序可能行为异常。 悬空指针虽然 free() 允许收回不再需要的内存，但是使用该函数会导致：悬空指针 (dangling pointer)。调用 free(p) 函数会释放 p 指向的内存块，但是不会改变 p 本身。如果忘记了 p 不再指向有效的内存块，修改其指向的内存是严重的错误，因为程序不再对此内存有任何控制权了。 12345char *p = malloc(4);...free(p);...strcpy(p, "abc"); // wrong 试图访问或修改释放掉的内存块会导致未定义的行为。 悬空指针很难发现，因为及格指针可能指向相同的内存块。在释放内存块后，全部的指针都悬空了。 链表运算符 . 的优先级高于运算符 * 运算符 right arrow selection -&gt; 产生左值： 1scanf("%d", &amp;new_node-&gt;value); 简单示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct node &#123; int value; struct node *next;&#125;;struct node *first = NULL;struct node *addToList(struct node *list, int n)&#123; struct node *newNode; newNode = (struct node *)malloc(sizeof(struct node)); if (newNode == NULL) &#123; printf("Error: malloc failed in addTolist()\n"); exit(EXIT_FAILURE); &#125; newNode-&gt;value = n; newNode-&gt;next = list; return newNode;&#125;struct node *readNumbers(void)&#123; struct node *first = NULL; int n; printf("Enter a series of integers (0 to terminame): "); for ( ; ; ) &#123; scanf("%d", &amp;n); if (n == 0)&#123;return first;&#125; first = addToList(first, n); &#125;&#125;struct node *searchList(struct node *list, int n)&#123; struct node *p; for (p = list; p != NULL; p = p-&gt;next) &#123; if (p-&gt;value == n)&#123;return p;&#125; &#125; return NULL;&#125;struct node *searchList(struct node *list, int n)&#123; for ( ; list != NULL; list = list-&gt;next) &#123; if (list-&gt;value == n) &#123;return list;&#125; &#125; return NULL;&#125;// BETTER WAYstruct node *searchList(struct node *list, int n)&#123; while (list != NULL &amp;&amp; list-&gt;value != n) &#123;list = list-&gt;next;&#125; return list;&#125; 删除示例 定位要删除的结点；（保留一个指向前一个结点的指针 previous，还有指向当前结点的指针 current） 改变前一个结点，从而使它“绕过”删除结点； 调用 free() 收回删除结点占用的内存空间。 1234567for (current = list, previous = NULL; current != NULL &amp;&amp; current-&gt;value != n; previous = current, current = current-&gt;next)&#123; ;&#125;previous-&gt;next = current-&gt;next;free(current); 删除结点的函数 123456789101112131415161718192021struct node *deleteFromList(struct node *list, int n)&#123; struct node *current, *previous; for (current = list, previous = NULL; current != NULL &amp;&amp; current-&gt;value != n; previous = current, current = current-&gt;next) &#123; ;&#125; // n was not found if (current == NULL)&#123;return list;&#125; // n is the first node if (previous = NULL) &#123;list = list-&gt;next;&#125; else &#123;previous-&gt;next = current-&gt;next;&#125; free(current); return list;&#125; 指向函数的指针一个很好的例子快速排序的函数原型 1void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 对 inventory 进行排序。 1qsort(inventory, numParts, sizeof(struct part), compareParts); qsort() 要求其形式参数类型为 void *，但我们不能通过 void * 型的指针访问 part 结构成员，而是需要指向结构 part 的指针。 1234567891011121314int compareParts(const void *p, const void *q)&#123; // void * 通用指针可以通过这种方式很容易地转换为 // 别的类型的指针 const struct part *p1 = p; const struct part *q1 = q; if (p1-&gt;number &lt; q1-&gt;number) &#123;return -1;&#125; else if (p1-&gt;number == q1-&gt;number) &#123;return 0;&#125; else &#123;return 1;&#125;&#125; 更加简明的实现： 123456789int compareParts(const void *p, const void *q)&#123; if (((struct part *) p)-&gt;number == ((struct part *) q)-&gt;number) &#123;return -1;&#125; else if (((struct part *) p)-&gt;number == ((struct part *) q)-&gt;number) &#123;return 0;&#125; else &#123;return 1;&#125;&#125; 通过移除 if 语句可以把函数 compareParts() 变得更短： 1234int compareParts(const void *p, const void *q)&#123; return ((struct part *) p)-&gt;number - ((struct part *) q)-&gt;number;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言命名和程序组织]]></title>
      <url>%2F2016%2F12%2F13%2FnameAndCodeStyleOfC-md%2F</url>
      <content type="text"><![CDATA[写程序的过程中，最难的事情之一就是命名。 命名C89 标准指出：以下划线后跟一个大写字母开头的名字是保留字，程序员不应该使用。 程序组织单文件摘自《C 语言程序设计 现代方法》第 10 章。清楚地讲解了一个程序，从将问题分解为若干任务，初步设计程序的构成，到实现程序的细节的整个过程。 一个单文件的组成顺序通常是： #include 指令； #define 指令； 类型定义； 外部变量声明； 除 main() 之外的函数原型； main() 的定义； 其他函数的定义。 示例程序：给一手牌分类背景在每个函数定义前放盒型注释可以给出函数名、描述函数的目的、讨论每个形式参数的含义、描述返回值（如果有的话）并罗列所有的副作用（如修改了外部变量的值）。例如，给一手牌分类：手中的每张牌都有花色（方块、梅花、红心和黑桃）和等级（2、3、4、5、6、7、8、9、10、J、Q、K、和 A）。不允许使用王牌，并且假设 A 是最高等级的。程序将读取一手 5 张牌，然后把手中的牌分为下列某一类（列出的顺序从最好到最坏）。 同花顺（即顺序相连又都是同花色）。 四张（4 张牌等级相同）。 葫芦（3 张牌是同样的花色，而另外 2 张牌是同样的花色）。 同花（5 张牌是同样花色的）。 顺子（5 张牌的等级顺序相连）。 三张（3 张牌的等级相同）。 两对。 一对。 其他牌 如果一手牌可分为两种或多种类别，程序将选择最好的一种： 为了便于输入，把牌的等级和花色简化如下（字母可以是大写也可以是小写）。 等级：2 3 4 5 6 7 8 9 t j q k a 花色：c d h s 如果用户输入非法牌或者输入同一张牌两次，程序将此牌忽略，产生错误消息，然后要求输入另外一张牌，如果输入为 0 而不是一张牌，就会导致程序终止。 程序任务分析 读入一手 5 张牌； 分析对子、顺子等情况 显示一手牌的分类 把程序分为 3 个函数分别完成上述 3 个任务，即 read_cards()、analyse_hand() 和 print_result() 函数。main() 只负责在无限循环中调用这些函数。这些函数需要共享大量的信息，所以让它们通过外部变量来进行交流。read_cards() 将与一手牌相关的信息存进几个外部变量中，然后 analyze_hand() 将检查这些外部变量，把结果分类放在便于 print_result() 函数显示的其他外部变量中。 analyze_hand() 需要知道每个等级和每个花色的牌的数量。建议使用两个数组，即 num_in_rank 和 num_in_suit。为了便于 read_cards() 函数检查重复的牌，还需要第三个数组 card_exists[][]。每次读取等级为 r 且花色为 s 的牌时，read_cards 函数都会检查 card_exists[r][s]的值是否为 true。如果是，表明已经录入过。如果不是，那么 read_cards() 函数把 true 赋值给 card_exists[r][s]。 read_cards() 和 analyze_hand 函数都需要访问数组 num_in_rank 和 num_in_suit，所以这两个数组必须是外部变量；而数组 card_exists[][] 只用于 read_cards() 函数，所以可将它设为此函数的局部变量。通常只有必要时才把变量设为外部变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些代码踩坑的总结]]></title>
      <url>%2F2016%2F12%2F12%2FCorrectCodeErrors%2F</url>
      <content type="text"><![CDATA[每个人在写代码时，都不可避免犯一些错误，而且往往会在上面花费不少时间，发现错误之后有时甚至觉得这简直智障。为了避免重复犯错，我将自己所犯过的错误记录下来，与读者（包括未来的自己）分享，希望能有所帮助。 2016Dec.Day 12不要在条件表达式中滥用自增自减符号不要在如下的条件表达式（一般为逻辑表达式或关系表达式）中滥用 ++ 或 --，在判断的时候自增自减有时候会造成隐蔽的错误，特别是对于一些全部变量和有多个 else if 的情况。 123456if (Expression1)&#123;...&#125;else if (Expression2)&#123;...&#125;...else 指向数组最顶端的索引由于数组开始的索引是 0，往数组中填入值，希望最新放入的元素索引能够正确，如下是一种不太好但是正确的实现。 123456789101112131415sum = 0; key = 0; is_const = NULL; token_xy.x = 0; token_xy.y = NULL; p_token_xy = &amp;token_xy; printf("Please input string:\n"); do &#123; ch = getchar(); program[sum++] = ch; &#125;while(ch != '#'); sum--; 这种实现有点啰嗦，虽然 `sum` 的确表示元素总数，但是为了以下的一些操作，`sum--;`，这样就有点尴尬。直接一开始让 `sum = -1;`，注释掉 `sum--;`，然后 `(╯°□°）╯︵ ┻━┻`，程序就出错了。 原因是数组的索引一开始就为 `-1` 了，`program[-1] = ch;` 导致了错误。应该改为 `program[++sum] = ch;` 。 Day 18在 C 语言这样变量作用域十分麻烦的语言中，注意：在给函数的形式参数命名时，不要和全局变量重名。如果重名，当该函数希望修改全局变量时，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DBreview]]></title>
      <url>%2F2016%2F12%2F11%2FDBreview%2F</url>
      <content type="text"><![CDATA[专业课——数据库系统原理的学习总结 绪论基本概念数据库 Database长期储存在计算机内、有组织的、可共享的大量数据集合。 数据库管理系统 DBMS位于用户与操作系统之间的一层数据管理软件。 数据管理的发展人工阶段文件系统阶段 记录内有结构；todo 数据的结构是靠程序定义和解释的； todo 数据只能是定长的；（可间接实现数据变长的要求，但是访问相应数据的应用程序复杂了） 数据的共享性差，冗余度大； 文件间相互独立，数据整体无结构；（可间接实现数据整体的有结构，但必须在应用程序中描述数据间的联系） 数据的最小存取单位是记录 todo。 数据库系统阶段1. 数据结构化2. 数据共享性高冗余度低易扩充3. 数据独立性高 todo 由 DBMS 的二级映像功能 物理独立性：用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变，从而简化了应用程序的编制，减少了应用程序的维护和修改。 4. 数据由 DBMS 统一管理和控制DBMS 提供的数据控制功能： 安全性 Security 完整性 Integrity 并发控制 Concurrency 数据库恢复 Recovery 数据模型概念模型1. 实体 Entity客观存在并可相互区别，可具体可抽象。 2. 属性 Attribute3. 码 Key唯一标识实体的属性集成为码。 注意：属性集——属性的集合 4. 域 Domain属性的取值范围称为该属性的域。 5. 实体型 Entity Type用实体名极其属性名集合来抽象和刻画同类实体称为实体型。例如：顾客（编号，姓名，性别，年龄，住址）。 6. 实体集 Entity Set7. 联系 Relationship]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言多文件注意事项]]></title>
      <url>%2F2016%2F12%2F08%2FcMultipleFiles%2F</url>
      <content type="text"><![CDATA[本文解决以下问题： 如何防止头文件被重复包含？ 已经防止头文件被重复包含，如何防止因全局变量重复定义而引起的链接错误，报错如 duplicate symbol _test in …？ 如果想了解全局变量和局部变量的相关细节，可以看看这篇 C 语言存储类详解 防止头文件被重复包含如果头文件 first.h 和 second.h 中都包含了头文件 duplicate.h，那么当同时引入前两个头文件时，duplicate.h 会被隐式地包含两次。 在大型的项目中，往往会引入很多头文件，为了防止上述问题，要在每一个头文件的程序头尾加上条件编译。 duplicate.h123456789#ifndef headername_h#define headername_h// insert all code here// 这里是你写的代码，下面还有一句预定义// 注意下面这句预定义不要掉了// 注意不要把代码写到下面那句定义的后面#endif 防止全局变量被重复定义全局变量重复定义的原因和报错内容虽然上述方法可以防止整个头文件被重复包含，但是编译器是按 .c 文件为单位编译成 .o 文件（ Linux 系统）或者 .obj 文件（ Windows 系统），然后将这些 .o 文件链接起来，最后与运行库链接形成可执行文件。 在两个 .c 文件中包含同一个 .h 文件，跟条件编译没有关系。在头文件中定义了全局变量，而多个 .c 文件中引入这个头文件，每个 .c 文件中都有这个全局变量，在链接的时候就会报重复定义变量的错误。 1duplicate symbol _duplicateVariableName in FileAddress 解决方法在 .c 文件中声明并初始化全局变量，在 .h 文件中用extern声明这个全局变量，注意只是声明，不能初始化。在其他需要这个全局变量的 .c 文件中引入这个头文件，就会包含这个extern的变量声明，在生成目标代码的时候，编译器就会链接到定义该全局变量的 .c 文件。如下示例： test_extern.h123456789#ifndef test_extern_h#define test_extern_h#include &lt;stdio.h&gt;// 声明外部链接extern double test; double test_extern_method(void);#endif /* test_extern_h */ test_extern.c123456789#include "test_extern.h"// 定义全局变量 testdouble test = 0.0;double test_extern_method(void)&#123; test++; return test;&#125; main.c12345678910#include "test_extern.h"// 包含了以上头文件就声明了全局变量 test // 编译器会链接到 test_extern.c 中的全局变量int main(int argc, const char * argv[]) &#123; test+= 1.0; test = test_extern_method(); printf("%lf\n", test); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言 0 从入门到并不精通]]></title>
      <url>%2F2016%2F12%2F01%2FC10Days0ToBasic%2F</url>
      <content type="text"><![CDATA[C 语言是古老而强大的语言，时至今日，应该怎样写 C 程序呢？ C 语言基础回顾与思考。 第 2 章 C 基本概念一个 C 语言程序编译和链接要把程序转化成机器可以执行的形式。通常包含下列 3 个步骤 预处理程序被送给预处理器 (preprocessor)。预处理器执行以 # 开头的命令——通常称为指令 (directive)。预处理器有点类似于编辑器，可以给程序添加内容、进行修改。 编译编译器 (compiler) 按 .c 文件为单位，将每个文件翻译成机器指令。 链接最后，链接器 (linker) 把由编译器产生的目标代码和所需的其他附加代码整合在一起，这样才产生完全可执行的程序。这些附加代码包括程序中用到的标准库函数等。 简单程序的一般形式即时是最简单的 C 程序也依赖 3 个关键的语言特性：指令（在编译前修改程序的编辑命令）、函数（被命名的可执行代码块，如 main 函数）和语句（程序运行时执行的命令）。 指令 directive在编译 C 程序之前，预处理器会首先会首先对其进行编辑。把预处理器执行的命令称为指令。 函数 function事实上，C 程序就是函数的集合。函数分为两大类：一类是程序员编写的函数，另一类是作为 C 语言实现的一部分提供的函数，后者被称为库函数，因为它们属于一个由编译器提供的函数“库”。 语句 statement语句是程序运行时执行的命令。每条语句要以分号结尾（但是符合语句不以分号结尾）。指令通常只占一行，不需要用分号结尾。 注释各种形式的注释，比如“盒形”注释。 C99 提供 // This is a comment. 的注释。这种注释风格的两个主要优点： 注释会在行末自动终止，所以不会出现未终止的注释意外吞噬部分程序的情况； 因为每行前面都必须有 //，所以多行的注释更加醒目。 变量和赋值类型每个变量都必须有一个类型 type 声明使用变量之前，必须先对其进行声明。注意：在 C 语言中，声明的语法并非 1类型 标识符； 而是 1基本类型 生成基本类型的东西 赋值定义常量的名字当程序含有常量时，建议给这些常量命名。建议使用宏定义的特性给常量命名： 1#define INCHES_PER_POUND 166 当宏包含运算符时，必须用括号把表达式括起来。示例： 123456789101112131415161718192021// Name: celsius.c// Purpose: Convert a Fahrenheit temperature to Celsius.#include &lt;stdio.h&gt;#define FREEZING_PT 32.0f#define SCALE_FACTOR (5.0f / 9.0f)int main(void)&#123; float fahrenheit, celsius; printf("Enter Fahrenheit temperature: "); scanf("%f", &amp;fahrenheit); celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR; printf("Celsius equivalent: %.1f\n", celsius); return 0;&#125; 标识符C89 标准声称标识符可以任意长，但却只要求编译器记住前 31 个字符（C99 中是 63 个字符）。 对于具有外部链接的标识符：C89 中只有前 6 个字符有效，且不区分大小写。C99 中，前 31 个字符有效，且字母区分大小写。 C 程序的书写规范每条预处理指令都要求独立成行。 程序中记号的空格没有严格限制，除非两个记号合并后会产生第三个记号。 gccgcc 的常用选项： -Wall 使编译器检测到可能的错误时生成警告消息。 -W 除了 -Wall 生成的警告信息外，还需要针对具体情况的额外警告消息。 -pedantic 根据 C 标准的要求生成警告消息。这样可以避免在程序中使用非标准特性。 -ansi 禁用 gcc 的非标准特性，并启用一些不太常用的标准特性。 -std=c89 或 -std=c99 指明使用哪个版本的 C 编译器来检查程序。 第 3 章 格式化输入／输出TODO printf()转换说明%m.pX 格式或 %-m.pX 格式 m 表示最小字段宽度 minimum field widthp 表示精度X 表示格式 第 4 章 表达式算术运算符% 要求操作数是整数，否则编译无法通过。 当运算符 / 和运算符 % 用于负操作数时，结果难以确定。 根据 C89 标准，如果两个操作数中有一个为负数，那么除法的结果可能是向上取整也可能是向下取整。（例如，-9/7 的结果既可以是 -1 也可以是 -2。）取决于编译器。i%j 的符号与具体实现有关。（例如，-9 % 7 的值可能是 -2 或者 5。） 根据 C99 标准，除法的结果总是向零截取（因此 -9/7 的结果是 -1），i%j 的值的符号与 i 的符号相同（因此 -9%7 的值是 -2）。 赋值运算符在许多编程语言中，赋值是语句；然而在 C 语言中，赋值就像 + 那样是运算符。换句话说，赋值操作产生结果，这就如同两个数相加产生结果一样。赋值表达式 v=e 的值就是赋值运算后 v 的值。因此，下面的表达式 i = 72.99f 的值是 72（不是 72.99）。将值赋给 i 是赋值运算符的副作用。 12345int i;float f;i = 72.99f; // i is now 72f = 136; // f is now 136.0 既然赋值是运算符，那么多个赋值可以串联在一起（但是笔者不建议这样做），比如： 1i = j = k = 0; 注意隐式类型转换，串在一起的赋值运算的最终结果可能不是预期的结果： 1234int i;float f;f = i = 33.3f; 由上可以发现串联赋值容易引发一些隐蔽的错误，建议不要这样做。 左值赋值运算符要求其左操作数必须是左值。 左值表示存储在计算机内存中的对象，而不是常量或计算的结果。变量是左值。 在赋值表达式的左侧放置任何其它类型的表达式都是不合法的： 12312 = i; // wrongi + j = 0; // wrong-i = j; 编译器会检测出这种错误，并给出诸如 “invalid lvalue in assignment” 这样的错误消息。 复合赋值v += e 不等价于 v = v + e 。从优先级的角度看：表达式 i *= j + k 和表达式 i = i * j + k 是不一样的。 自增自减后缀 ++ 和后缀 -- 比一元的正号、符号优先级高，且为左结合。前缀 ++ 和前缀 -- 和一元的正号、符号优先级相同，且为右结合。 看懂了也懒得记，记住了也懒得在程序中分辨对吗？那就不要在复杂的表达式中滥用 ++ 和 -- 。 计算 v += e 只会求一次 v 的值，而计算 v = v + e 会计算两次 v 的值。注意下面这个例子： 123a[i++] += 2;a[i++] = a[i++] + 2; 复杂表达式求值这个部分可以先跳过不看。 TODO 也许会碰到很令人苦恼的复杂表达式（所以真的不要写这样的表达式哦(・ω・)ノ），那就借助官方的 C 语言运算符表，找到最高优先级的运算符，用圆括号将运算符和相应的操作数扩起来，将其看作一个单独的操作数。重复上述操作直到将表达式完全加上圆括号。 1a = b += c++ - d + --e / -f ; 后缀 ++ 优先级最高，在后缀 ++ 和相关操作数的周围加上圆括号 1a = b 子表达式的求值顺序表达式语句任何表达式都可以作为语句 键盘上的误操作很容易造成“什么也不做”的表达式语句。例如本想输入 i = j;，但是却错误地输入 i + j;，因为 = 和 + 两个字符在键盘的同一键上，很可能发生这样的错误，某些编译器可能会检查出无意义的表达式语句，会显示类似 “statement with no effect” 的警告。 选择语句逻辑表达式关系运算符优先级低于算术运算符，左结合。 if 语句C89 中的布尔值由于 C89 标准中没有定义布尔类型，需要自己定义，较好的方案是： 12345678#define TRUE 1#define FALSE 0int flag;flag = FALSE;...flag = TRUE; C99 中的布尔值C99 提供了 _Bool 型，_Bool 是无符号整型，所以其实际上就是整型变量；但是和一般的整型不同，_Bool 只能赋值为 0 或 1，一般往 _Bool 变量中存储非零值会导致变量赋值为 1。1_Bool flag; 除了 _Bool 类型的定义，C99 还提供了一个新的头 &lt;stdbool.h&gt;，这使得操作布尔值更加容易。该头提供了 bool 宏，用来代表 _Bool。该头文件还提供 true 和 false 两个宏。如果程序中包含了 &lt;stdbool.h&gt;，可以这样写： 123456789#include &lt;stdbool.h&gt;...bool flag;flag = true;...flag = false; switch 语句123456switch (controlExpression)&#123; case constantExpression0: statements; ... case constantExpression0: statements; default: statement&#125; 三个组成部分： controlExpression 控制表达式。switch 后边必须跟着由圆括号扩起来的整数表达式。C 语言把字符当做整数来处理，因此在 switch 语句中可以对字符进行判定。但是，不能用浮点数和字符串。 分支符号。每个分支开头的 case constantExpression，constantExpression 常量表达式像是很普通的表达式，但是不能包含变量和函数调用。因此，5 是常量表达式，5+10 也是常量表达式，但是，n + 10 不是常量表达式（除非 n 是表示常量的宏）。分支符号的常量表达式的值必须是整数（字符也可以）。 语句。每个分支标号的后边可以跟任意数量的语句。不需要用花括号把这些语句括起来。每组语句的最后一句通常是 break 语句。 忘记使用 break 语句是编程时常犯的错误。虽然有时会忽略 break 以便多个分支共享代码，但通常情况下省略 break 是因为疏忽。 故意从一个分支跳转到下一个分支的情况是非常少见的，因此最好明确指出省略 break 语句的情况。 123456789switch (grade)&#123; case 4: case 3: case 2: case 1: num_passing++; // FALL THROUGH case 0: total grades++; break;&#125; 循环基本类型这句话实在是太棒了，摘自《C 语言程序设计 现代方法》 计算机处理的是数而不是符号。我们用对行为的算术化程度来衡量我们的理解力。 读／写读／写浮点数读取 double 类型的值时，在 e, f, g 前放置字母 l，只在 scanf 函数格式串中使用 1，不能在 printf函数格式串中使用，e, f, g 用来写 float 和 double 类型的值。C99 允许 printf 函数调用时使用 %le 等，但是字母 l 不起作用。 读／写字符scanf() 不会跳过空白字符，如果要强制 scanf() 在读入字符前跳过空白字符，需要在格式串中的转换说明 %c 前面加上一个空格： 1scanf(" %c", &amp;ch); 类型定义1typedef int Bool; 将类型名的首字母大写不是必须的，只是 一些 C 语言程序员的习惯。 类型定义的优点如果选择了有意义的类型名，类型定义时程序更加容易理解。例如，假设变量 cash_in 和变量 cash_out 将用于存储美元数量。把 Dollars 声明成 1typedef float Dollars; 并且随后写出 1Dollars cash_in, cash_out; 这样的写法比下面的写法更有实际意义： 1float cash_in, cash_out; 类型定义还可以使程序更容易修改。如果稍后决定 Dollars 实际应该定义为 double 类型，那么只需要改变类型定义就可以了： 1typedef double Dollars; 数组一维数组数组下标数列反向。在下面的程序中将看到，宏和数组联合使用非常有效，如果以后要改变数组的大小，只需要编辑 N 的定义并且重新编译程序就可以了，甚至连提示也仍然是正确的。 1234567891011121314151617181920212223242526// Name: reverse.c// Purpose: Reverses a series of numbers.#include &lt;stdio.h&gt;#define N 10int main(void)&#123; int a[N], i; printf("Enter %d numbers: ", N); for (i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;a[i]); &#125; printf("In reverse order:"); for (i = N-1; i &gt;= 0; i--) &#123; printf(" %d", a[i]); &#125; printf("\n"); return 0;&#125; 数组初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;int main()&#123; // 整形数组的初始化 int arrayInt[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // 如果初始化式比数组短，那么数组中剩余的元素赋值为 0 int a[10] = &#123;1, 2, 3, 4&#125;; // initial value of a is &#123;1, 2, 3, 4, 0, 0, 0, 0, 0, 0&#125; // 利用这一特性，可以很容易地把数组初始化为全 0 // 初始化式完全为空是非法的，所以要在大括号中放上一个 0 int arrayLazy[10] = &#123;0&#125;; int i; // 字符型数组的初始化 // 无尺寸数组，C 自动完成计算数组大小的工作 char arrayChar1[] = "How are you?"; char arrayChar2[13] = "How are you?"; char arrayChar3[13] = &#123;'H', 'o', 'w', ' ', 'a', 'r', 'e', ' ', 'y', 'o', 'u', '!', '\0'&#125;; int array2D[4][4] = &#123; &#123;12, 18, 6, 25&#125;, &#123;23, 10, 32, 16&#125;, &#123;25, 63, 1, 63&#125;, &#123;0, 0, 27, 98&#125; &#125;; // 对于二维无尺寸数组的初始化， // 数组第二个下标的尺寸是必须给出的 int array2Dx6[][2] = &#123; &#123;1, 50&#125;, &#123;45, 2&#125;, &#123;2, 0&#125;, &#123;12, 32&#125;, &#123;42, 33&#125;, &#123;15, 18&#125; &#125;; for (i = 0; i &lt; 10; i++) &#123; printf("%d ", arrayLazy[i]); &#125; printf("\n"); return 0;&#125; 指定初始化式经常有这样的情况：数组中只有相对较少的元素需要进行显示的初始化，而其他元素可以进行默认赋值。 1int a[15] = &#123;0, 0 , 29, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 48&#125;; 如果对于较大的数组，这样的情况下赋值就更为麻烦——两个非 0 元素之间有 200 个 0 的情况。 C99 中的指定初始化式可以用于解决这一问题。上面的额例子可以使用指定初始化写为： 1int a[15] = &#123;[2] = 29, [9] = 7, [14] = 48&#125;; 除了可以使赋值变得更简短、更易读之外，指定初始化式还有一个优点：赋值的顺序不再是一个问题，我们也可以将先前的例子重新写为： 1int a[15] = &#123;[14] = 48, [9] = 7, [2] = 29&#125;; 指示符必须是整型常量表达式。如果待初始化的数组长度为 n，则么个指示符的值都必须在 0 到 n - 1 之间。但是如果数组的长度是省略的，指示符可以是任意非负整数；对于后一种情况，编译器将根据最大的提示符推断出数组的长度。在接下来的例子中，指示符最大值为 23，因此数组的长度为 24: 1int b[] = &#123;[5] = 10, [23] = 13, [11] = 33, [15] = 29&#125;; 初始化式中可以同时使用老方法和新方法，但是个人觉得这样会有一点混乱： 12int mix[10] = &#123;5, 1, 9, [4] = 3, 7, 2, [8] = 6&#125;;// 5 1 9 0 3 7 2 0 6 0 其实介绍这种特性只是为了能看懂别人这样写的程序，如果不支持 C99 的环境，其实，用笨办法 for 和 if 的组合依然能达到这样的效果，虽然写法上没有这么简洁，本质上都是一样的。 检查数中重复出现的数字 123456789101112131415161718192021222324252627282930// Name: repdigit.c// Checks numbers for repeated digits#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; bool digit_seen[10] = &#123;false&#125;; int digit; long n; printf("Enter a number: "); scanf("%ld", &amp;n); while (n &gt; 0) &#123; digit = n % 10; if (digit_seen[digit]) &#123;break;&#125; digit_seen[digit] = true; n /= 10; &#125; if (n &gt; 0) &#123;printf("Repeated digit\n");&#125; else &#123;printf("No repeated digit\n");&#125; return 0;&#125; 这个程序用到了 bool true 和 false 等名称，它们在 C99 的 &lt;stdbool.h 头中定义。如果编译器不支持，需要自己定义，在 main() 的上面加上以下代码： 123#define true 1#define false 0typedef int bool; 对数组使用 sizeof 运算符运算符 sizeof 可以确定数组的大小（字节数）。如果数组 a 有 10 个整数，那么 sizeof(a) 通常为 40。用数组大小除以数组元素的大小可以得到数组的长度： 1sizeof(a)/sizeof(a[0]); 当需要数组长度时，可采用上述表达式，比如，数组清零操作： 123456#define SIZE ((int)(sizeof(a)/sizeof(a[0])))for (i = 0; i &lt; SIZE; i++)&#123; a[i] = 0;&#125; 如果使用这种方法，即使数组长度在日后需要改变，也不需要改变循环。当然，利用宏也有类似的效果。 二维数组多维数组初始化如果初始化式没有达到足以填满整个多维数组，那么把数组中剩余的元素赋值为 0。例如，下面的初始化式只填充了数组 m 的前三行，后面两行将赋值为 0: 12345int m [5][9] = &#123; &#123;1, 1, 1, 1, 1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1, 1, 1, 1, 1&#125;&#125;; 如果内层的列表没有达到足以填满数组的一行，那么把此行剩余的元素初始化为 0: 123456int m[5][9] = &#123; &#123;1, 1, 1, 1, 1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1, 1, 1&#125;&#125;; C99 的指定初始化式对多维数组也有效。例如： 1double ident[2][2] = &#123;[0][0] = 1.0, [1][1] = 1.0&#125;; 其中没有指定的值都默认设置为 0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Name: deal.c// deals a random deck of cards// 程序负责发一副标准纸牌// 每张标准纸牌都有一个花色//（梅花♣️ clubs、方块♦️ diamonds、红心♥️ hearts 或黑桃♠️ spades）// 为了避免两次都拿到同一张牌，需要记录已经选择过的牌// 用 in_hand 的二维数组，4 row - 13 column // 数组中每个元素对应着 52 张纸牌中的一张。#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define NUM_SUITS 4#define NUM_RANKS 13int main(void)&#123; bool in_hand[NUM_SUITS][NUM_RANKS] = &#123;&#123;false&#125;&#125;; int num_cards, rank, suit; const char rank_code[] = &#123;'3', '4', '5', '6', '7', '8', '9', 't', 'j', 'q', 'k', 'a', '2'&#125;; const char suit_code[] = &#123;'c', 'd', 'h', 's'&#125;; srand((unsigned) time(NULL)); printf("Enter number of cards in hand: "); scanf("%d", &amp;num_cards); printf("Your hand:"); while (num_cards &gt; 0) &#123; // picks a random suit suit = rand() % NUM_SUITS; // picks a random rank rank = rand() % NUM_RANKS; if (!in_hand[suit][rank]) &#123; in_hand[suit][rank] = true; num_cards--; printf(" %c%c", rank_code[rank], suit_code[suit]); &#125; &#125; printf("\n"); return 0;&#125; C99 中的变长数组主要限制是它们没有静态存储期限，另一个限制是变长数组没有初始化式。 C99 不允许 goto 语句绕过变长数组的声明。因为在程序执行的过程中，遇到变长数组时通常就为该变长数组分配内存空间了。用 goto 语句绕过变长数组的声明可能会导致程序对未分配空间的数组中的元素进行访问。 数组的复制逐个复制1234for (i = 0; i &lt; N; i++)&#123; a[i] = b[i]'&#125; memcpy()使用来自 &lt;string.h&gt; 头的函数 memcpy()，它是一个底层函数，把字节从一个地方简单复制到另一个地方。将数组 b 复制到数组 a 中，使用的格式如下： 1memcpy(a, b, sizeof(a)); 许多程序员倾向于使用 memcpy()，特别式处理大型数组时，因为它潜在的速度比普通循环更快。 第 9 章 函数函数的定义和调用函数定义12345返回类型 函数名（形式参数列表）&#123; 声明 语句&#125; 如果返回类型很冗长，比如 unsigned long int 类型，那么把返回类型单独放在一行是非常有用的。 函数调用如果丢失圆括号（没有参数的时候有可能就忘记了写括号）就无法进行函数调用。 1234567891011121314151617181920212223242526272829303132// Name: prime.c// Purpose: Test whether a number is prime.#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;bool is_prime(int n)&#123; int divisor; if (n &lt;= 1)&#123;return false;&#125; for (divisor = 2; divisor*divisor &lt;= n; divisor++) &#123; if (n % divisor == 0)&#123;return false;&#125; &#125; return true;&#125;int main(void)&#123; int n; printf("Enter a number: "); scanf("%d", &amp;n); if (is_prime(n)) &#123;printf("Prime\n");&#125; else &#123;printf("Not prime\n");&#125; return 0;&#125; 函数声明最好不要省略形式参数的名字，因为这些名字可以说明每个形式参数的目的，不过《C 语言程序设计 现代方法》中提到： 问：为什么有的程序员在函数原型中故意省略参数名字？保留这些名字不是更方便吗？答：省略原型中的参数名字通常是出于防御目的。如果恰好有一个宏的名字跟参数一样，预处理时参数的名字会被替换，从而导致相应的原型被破坏。这种情况在一个人编写的小程序中不太可能出现，但是在很多人编写的大型应用程序是可能出现的。 实际参数实际参数通过值传递，形式参数的修改不会影响到相应的实际参数。 实际参数的转换TODO 变长数组的形式参数多种函数原型写法： 1int sum_array0(int n, int a[n]); 另一种写法是用 *（星号）取代数组长度： 1int sum_array1(int n, int a[*]); 使用 * 的理由是：函数声明时，形式参数的名字时可选的。如果第一个参数定义被省略了，那么就没有办法说明数组 a 的长度是 n，而星号的使用则为我们提供一个线索——数组的长度与形式参数列表中前面的参数相关 1int sum_array(int, int[*]); 如果变长数组参数是多维的则更加实用。 1234567891011121314int sum_two_dimensional_array(int n, int m, int a[n][m])&#123; int i, j, sum = 0; for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt; m; j++) &#123; sum += a[i][j]; &#125; &#125; return sum;&#125; 递归递归经常作为分治法 (divide and conquer) 的结果自然地出现。 TODO 第 10 章 程序结构]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C 语言存储类详解]]></title>
      <url>%2F2016%2F11%2F30%2FC-5-storage-class-specifiers%2F</url>
      <content type="text"><![CDATA[如果对以下问题有疑惑，不妨看看全文。 在编写多文件的 C 语言程序时，在 C 源文件中使用了同名的变量时，应该如何保护有些变量不被意外修改？ 究竟需要初始化变量吗？什么时候，应该如何，初始化什么种类的变量？ 静态变量 static variable 中的静态究竟指什么？是指值不能改变吗？ 一个 C 语言变量会存放在哪里，可以指定它的存放位置吗？ 为什么有些算法书建议，将很大的数组放在所有函数之外声明？ 由于要写 C 语言编译器，整理一下 C 语言中不太清楚的知识。 C 语言中有 5 个作为存储类说明符 (storage class specifier) 的关键字，它们是auto register static extern以及typedef。 本文主要摘自 《C Primer Plus》第 12 章。 存储类、链接和内存管理C 使用作用域、链接和存储时期来定义 5 种存储类，首先来认识一下这三个术语。 作用域——程序中可以访问一个标识符的一个或多个区域。 代码块作用域 block scope在代码块（一对花括号中包含的代码）中定义的变量具有代码块作用域，从该变量被定义的地方到相应代码块的结尾，该变量均可见。 另外，函数的形式参量尽管在函数的开始花括号前进行定义，同样也具有代码块作用域，隶属于包含函数体的代码块。 下列代码中变量 cleo 和 patrick 都有直到结束花括号的代码块作用域。 123456double blocky(double cleo)&#123; double patrick = 0.0; ... return patrick;&#125; 在一个内部代码代码块中声明的变量，其作用域只局限于该代码块： 12345678910111213double blocky(double cleo)&#123; double patrick = 0.0; int i; for (i = 0; i &lt; 10; i++) &#123; double q = cleo * i; // q 作用域的开始 ... patrick *= q; &#125; // q 作用域的结束 ... return patrick;&#125; 在这个例子中，q 的作用域被限制在内部代码块内，只有该代码块内的代码可以访问 q。 C99 之前（你用的 Xcode 完全支持 C99），具有代码作用域的变量都必须在代码块开始处进行声明，C99 开始允许在一个代码块中任何位置声明变量。 12for (int i = 0; i &lt; 10; i++)&#123;printf("A C99 feature: i = %d", i);&#125; 作为这一新功能的一部分，C99 把代码块的概念扩大到包括由 for循环、while 循环或者if语句所控制的代码——即使这些代码没有用花括号括起来。 文件作用域 file scope一个在所有函数之外定义的变量具有文件作用域。具有文件作用域的变量从它定义处到包含该定义的文件 结尾处都是可见的。除非被同名的局部变量屏蔽。 函数原型作用域 function prototype scope适用于函数原型中使用的变量名。函数原型作用域从变量定义处一直到原型声明的末尾。这意味着编译器在处理一个函数原型的参数时，它所关心的只是该参数的类型。名字通常是无关紧要的，名字起作用的一种情形是变长数组参量： 1void use_a_VLA(int n, int m, ar[n][m]); 如果在方括号中使用了变量名，则该变量名必须是在原型中已经声明了的。 链接，一个 C 变量具有下列链接之一：外部链接 external linkage具有外部链接的变量可以在一个 多文件程序 的 任何 地方使用。 内部链接 internal linkage在定义时使用了存储类说明符static，可以在定义该变量的文件的任何地方使用。 空链接 no linkage具有代码块作用域和函数原型作用域的变量有空链接。意味着它们由其定义所在的代码块或函数原型所私有。 1234567int giants = 5; // 文件作用域，外部链接static int dodgers = 5; // 文件作用域，内部链接int main()&#123; int i = 0; // 空链接 ...&#125; 存储时期一个 C 变量有以下两种存储时期之一： 静态存储时期 static storage duration 具有文件作用域的变量，具有静态存储时期。 注意对于具有文件作用域的变量，关键词 static 表明链接类型，并非存储时期。一个使用 static 声明了的文件作用域变量具有内部链接，而所有文件作用域变量，无论它是具有内部链接，还是具有外部链接，都具有静态存储时期。 在函数内，定义时，声明为 static 的变量。 自动存储时期 auto storage duration在代码块内，在定义时，没有用关键字static声明的变量具有自动存储时期。在程序进入定义这些变量的代码块时，将为这些变量分配内存；当退出这个代码块时，分配的内存将被释放。该思想吧自动变量使用的内存视为一个可以重复使用的工作区或者暂态内存。例如，在一个函数调用结束后，它的变量所占用的内存可以被用来存储下一个被调用函数的变量。 5 种存储类C 使用作用域、链接和存储时期来定义 5 种存储类，见下表： 存储类 存储时期 作用域 链接 声明方式 自动 自动 代码块 空 代码块内 寄存器 自动 代码块 空 代码块内，使用 关键字 register 空链接的静态 静态 代码块 空 代码块内，使用关键字 static 具有外部链接的静态 静态 文件 外部 所有函数之外 具有内部链接的静态 静态 文件 内部 所有函数之外，使用关键字 static 自动变量可用关键字 auto显示定义存储类型。 默认情况下，在代码块或函数的头部定义的任意变量（没有用 static 显示声明）都属于自动存储类。 1234int main(void)&#123; auto int plox;&#125; 再来仔细看一下嵌套代码块。只有定义变量的代码块及其内部的任何代码块可以访问这个变量，这是一个： 1234567891011int loop (int n)&#123; int m; // m 的作用域 scanf("%d", &amp;m); for (int i = m; i &lt; n; i++) &#123; // m 和 i 的作用域 puts("i is local to a sub-block\n"); &#125; return m; // m 的作用域，i 已经消失&#125; 变量 i 仅在内层花括号中可见，如果试图在内层代码块之前或之后使用该变量，将得到一个编译错误。变量 n 和 m 在函数头部和外层代码块中定义，在整个函数中可用，一直存在到函数终止。 如果在内层代码块定义了一个具有和外层代码块变量同一名字的变量，内层定义会暂时覆盖 (hide) 外部定义，但是当运行离开内层代码块时，外部变量重新恢复作用。 不带{}的代码块在 C99 中，语句若为循环或者 if 语句的一部分，即使没有使用{}，也认为是一个代码块，和内层花括号的效果一样。 ⚠️注意：有些编译器可能不支持 C99 作用域规则，其他编译器可能提供一个激活这些规则的选项。例如用 gcc 在命令行下编译filename.c这个文件，需要使用gcc -std=c99 filename.c -o filename 自动变量的初始化除非显示地初始化自动变量，否则它不会被自动初始化。考虑如下声明： 123456int main(void)&#123; int repid; int tents = 5; ...&#125; 变量tents初始化为 5，而变量repid的初值则是，先前占用分配给它的空间的任意值。不要指望这个值是 0。 寄存器变量可以用存储类说明符register声明寄存器变量。 12345int main(void)&#123; register int quick; ...&#125; 如果幸运，寄存器变量可以被存储在 CPU 寄存器中，或者存储在速度最快的可用内存中，从而可以比普通变量更快地被访问和操作。因为寄存器变量多是存在一个寄存器而非内存中，所以无法获得寄存器变量的地址。但是在其他的许多方面，寄存器变量域自动变量一样——都有代码块作用域、空链接以及自动存储时期。 之所以说“如果幸运”，是因为声明一个寄存器变量仅是一个请求，而非一条直接的命令。编译器必须在您的请求与可用寄存器的个数或可用高速内存的数量之间做权衡，所以您可能达成不了自己的愿望。这种情况下，变量称为一个普通的自动变量；然而，您依然不能对它使用地址运算符。 可以使用register声明的类型是有限的。例如，处理器可能没有足够大的寄存器来容纳 double类型。 具有代码块作用域的静态变量通过使用存储类说明符static（这提供了静态存储时期）在代码块内声明（这提供了代码块作用域和空链接）创建。 静态变量 (static variable)中“静态”是指变量的位置固定不动。 具有文件作用域的变量自动（也是必须的）具有静态存储时期。也可以创建具有代码块作用域，兼具静态存储的局部变量。也就是说，从一次函数调用到下一次调用，计算机都记录着它们的值。 1234567891011121314151617181920212223#import &lt;stdio.h&gt;void trystat(void);int main(int argc, const char * argv[])&#123; int count; for(count = 1; count &lt;= 3; count++) &#123; printf("Here comes iteration %d: \n", count); trystat(); &#125; return 0;&#125;void trystat(void)&#123; int fade = 1; static int stay = 1; printf("fade = %d and stay = %d\n", fade++, stay++);&#125; 运行结果为： 1234567Here comes iteration 1: fade = 1 and stay = 1Here comes iteration 2: fade = 1 and stay = 2Here comes iteration 3: fade = 1 and stay = 3Program ended with exit code: 0 静态变量stay记得它的值曾被加 1，而变量fade每次都重新开始。这表明初始化的不同：在每次调用trystat()时fade都被初始化，而stay只在编译trystat()时被初始化一次。 如果不显式地对静态变量进行初始化，它们将被初始化为 0。以下两个声明看起来很相似： 12int fade = 1;static int stay = 1; 然而，第一个语句确实是函数trystat()的一部分，每次调用该函数时都会执行它——运行时动作。而第二个语句不是该函数的一部分。如果用调试程序逐步运行改程序，会发现，程序看起来跳过了那一步。那是因为静态变量和外部变量在程序调入内存时已经就位了。把这个语句放在trystat()函数中是为了告诉编译器只有函数trystat()可以看到该变量。它不是在运行时执行的语句。 对函数参量不能使用static 1int wontwork(static int flu); // 不允许 具有外部链接的静态变量具有外部链接的静态变量具有文件作用域、外部链接和静态存储时期。这一类型被称为外部存储类 (external storage class)，这一类型的变量称为外部变量 (external variable)。 把变量的定义声明放在所有函数之外，即创建了一个外部变量。为了使程序更加清晰，可以在使用外部变量的函数中通过使用extern关键字来再次声明它。 如果变量是在别的文件中定义的，使用extern来声明该变量就是必须的。 12345678910int Errupt; // 外部定义的变量double Up[100]; // 外部定义的数组// 必须的声明，因为 Coal 在其他文件中定义extern char Coal; int main(void)&#123; ...&#125; 外部变量初始化如果不对外部变量进行初始化，它们将自动被赋初值 0。这一原则也适用于外部定义的数组元素。不同于自动变量，只可以用常量表达式来初始化文件作用域变量: 1234int x = 10; // 可以，10 是常量int y = 3 * 20; // 可以，一个常量表达式size_t z = sizeof(int); // 可以，一个常量表达式int x2 = 2 * x; // 不可以，x 是一个变量 （只要类型不是一个变长数组，sizeof 表达式就被认为是常量表达式。） 外部名字C99 标准要求编译器识别局部标识符的前 63 个字符和外部标识符的前 31 个字符。 定义和声明12345int tern = 1; // 定义 tern main()&#123; external int tern; // 使用在其他地方定义的 tern 变量 这里，tern 第一次声明为变量留出了存储空间，它构成了变量的定义。第二次声明只是告诉编译器要使用先前定义的变量 tern，因此不是一个定义。第一次声明称为定义声明 (definig declaration)，第二次声明称为引用声明 (referencing declararion)。关键字 extern 表明该声明不是一个定义，因为它指示编译器参考其他地方。 如果这样做： 123extern int tern;int main(void)&#123; 那么编译器假定 tern 的真正定义是在程序中其他某个地方，也许是在另一文件中。这样的声明不会引起空间分配。因此，不要用关键字 extern 来进行外部定义；只用它来引用一个已经存在的外部定义。 一个外部变量只可进行一次初始化，而且一定是在变量被定义时进行。下面的语句是错的：extern char permis = &#39;Y&#39;; // 错误 因为关键字extern的存在标志着这是一个引用声明，而非定义声明。 使用复杂的 C 程序往往使用多个独立的代码文件。有些时候，这些文件可能需要共享一个外部变量。ANSI C 通过在一个文件中定义变量，在其他文件中引用声明这个变量来实现共享。也就是说，除了一个声明（定义声明）外，其他所有声明都必须使用关键字extern，并且只有在定义声明中才可以对该变量进行初始化。 注意：除非在 B 文件中也声明了该变量（通过使用extern），否则在一个文件中定义的外部变量不可以用于第二个文件。 一个外部变量声明本身只是使一个变量可能对其他文件可用。 具有内部链接的静态变量这种存储类的变量具有静态存储时期，文件作用域以及内部链接。通过使用存储类说明类static在所有函数外部进行定义（正如定义外部变量那样）来创建一个这样的变量： 123static int svil = 1; // 具有内部链接的静态变量int main(void)&#123; 可以在函数中使用存储类说明符extern来再次声明任何具有文件作用域的变量。这样的声明并不改变链接。 存储类说明符C 语言中有 5 个作为存储类说明符 (storage class specifier) 的关键字，它们是auto register static extern以及typedef。 typedef与内存存储无关，由于语法原因被归入此类。不可以在一个声明中使用一个以上存储类说明符，意味着不能将其他任一存储类说明符作为typedef的一部分。 存储类和函数函数也具有存储类。函数可以是外部的（默认情况下）或者静态的（ C 99增加了第三种可能性，即内联函数）。 外部函数可被其他文件中的函数调用，而静态函数只可以在定义它的文件中使用。 使用哪种存储类尽量使用 auto。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objectiv-C 学习笔记]]></title>
      <url>%2F2016%2F11%2F30%2FObjectiv-C-Program%2F</url>
      <content type="text"><![CDATA[虽然已经有了 Swift，但是还是有很多 Objective-C 的项目，这门语言还是有必要学一学。如果已经有 C 语言的基础，相信你能很快上手。OC 是完全兼容 C99 的，所以也会先回顾一下 C 语言的重要内容。 如果还完全不会用 Xcode 创建项目和文件，可以看看 Xcode 使用笔记 0 新司机上路 C 语言基础回顾布尔值Xcode 支持 C99 标准 1_BOOL a = true; 注意在 Objective-C 中，BOOL类型使用 8 位存储空间，如果不小心将一个大于 1 字节的整型值（比如short或int）付给一个BOOL变量，那么只有低位字节会用作BOOL值，如果该低位字节刚好为 0（比如说 8960，写成十六进制为0x2300），BOOL值将会被认作是 0 ，即 NO值，故不要混用数字和BOOL类型。 函数 如果变量是“与某块数据相关联的名称”，那么函数就是“与某块代码相关联的名称”。 发现代码中的重复，提取具有共通性的部分并将其用独立的函数处理，接着添加参数处理差异部分。 局部变量、帧和栈函数可以有很多局部变量，这些局部变量都保存在函数的帧 (frame) 中。 使用栈 (stack) 来描述帧在内存中存储的地点。执行函数时，函数的帧会在栈的顶部被创建出来。函数执行结束时，我们会说函数返回了。也就是说，其帧会退出栈，等待下一个调用它的函数继续执行。 全局变量与静态变量在函数外声明的变量称为全局变量。复杂的程序会涉及大量的文件，包含不同的函数。这些文件中的代码都能访问全局变量。在不同的文件中共享变量不一定都是好事，有时候会引起很严重的混淆问题。 为此，C 语言引入了静态变量 (static variable)概念。只有那些声明了静态变量的文件才可以访问静态变量。详见下一小节。 存储类、链接和内存管理C 语言中有 5 个作为存储类说明符的关键字，它们是auto register static extern以及typedef。 typedef与内存存储无关，由于语法原因被归入此类。不可以在一个声明中使用一个以上存储类说明符，意味着不能将其他任一存储类说明符作为typedef的一部分。 C 使用作用域、链接和存储时期来定义 5 种存储类，见下表： 存储类 存储时期 作用域 链接 声明方式 自动 自动 代码块 空 代码块内 寄存器 自动 代码块 空 代码块内，使用 关键字 register 空链接的静态 静态 代码块 空 代码块内，使用关键字 static 具有外部链接的静态 静态 文件 外部 所有函数之外 具有内部链接的静态 静态 文件 内部 所有函数之外，使用关键字 static 详见：C 语言存储类详解 指针通过*运算符，可以访问保存在某个地址中的数据。 不同数据类型的大小sizeof()会返回一个类型为size_t的数，与之对应的格式是%zu，较少用到。示例： 1234567891011121314#import &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int i = 17; int *addressOfI = &amp;i; printf("i stores its value at %p\n", addressOfI); *addressOfI = 89; printf("Now i is %d \n", i); printf("An int is %zu bytes\n", sizeof(int)); printf("A pointer is %zu bytes\n", sizeof(int *)); return 0;&#125; 运行程序，如果指针长度是 4 个字节，那么该程序就是在 32 位环境下运行，8——64 位环境。 NULLNULL就是 0（地址也是数字）。在if的条件中，很方便判断指针是否为空： 1234567float *myPointer;...// myPointer 指针是否为空？if(myPointer)&#123; ...// myPointer 非空&#125; 或者用较简洁的三元运算符 123// 如果 measureGravityPtr 是空值，则计算重力值float actualGravity = measureGravityPtr? *measuredGravityPtr : estimatedGravity(planetRadius); 通过引用传递通过一个实例来学习，其中调用modf()函数并传入一个double类型数，可以得到该浮点数的整数部分和小数部分。 12345678910111213141516171819202122#import &lt;stdio.h&gt;#import &lt;math.h&gt;int main(int argc, const char * argv[])&#123; double pi = 3.14; double integerPart; double fractionPart; // 将 integerPart 的地址作为实参传入 fractionPart = modf(pi, &amp;integerPart); // 获取 integer 地址上的值 printf("integerPart = %.0f, fractionPart = %.2f\n", integerPart, fractionPart); return 0;&#125;// 运行结果// integerPart = 3, fractionPart = 0.14// Program ended with exit code: 0 调用函数时传入某个地址，然后由函数将数据传入该地址指向的内存，这种参数传入方式称为通过引用传递 (pass-by-refrence)。 以下是一个很实用，很简单的通过引用传递参数的例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 将公制单位米转换成非公制单位的英尺和英寸，// 需要读取一个浮点数，返回两个浮点数。// 调用函数时，要为 meters 传入相应的值。// 此外，还要提供两个地址，用于保存 feet 和 inches。#import &lt;stdio.h&gt;#import &lt;math.h&gt;void metersToFeetAndInches(double meters, unsigned int *ftPtr, double *inPtr)&#123; // 这个函数假定 meters 的值是非负数 // 将 meters 变量转化为 feet 的值，类型为浮点数。 double rawFeet = meters * 3.281; // 计算类型为无符号整型 feet 变量的值 unsigned int feet = (unsigned int)floor(rawFeet); // 将 feet 变量的值储存在提供的地址里 printf("Storing %u to the address %p \n", feet, ftPtr); *ftPtr = feet; // 计算英寸 double fractionalFoot = rawFeet - feet; double inches = fractionalFoot * 12.0; // 将 inches 变量的值储存在传入的地址里 printf("Storing %.2f to the address %p \n", inches, inPtr); *inPtr = inches;&#125;int main(int argc, const char * argv[])&#123; double meters = 3.0; unsigned int feet; double inches; metersToFeetAndInches(meters, &amp;feet, &amp;inches); printf("%.1f meters is equal to %d feet and %.1f inches.\n", meters, feet, inches); return 0;&#125;// 运行结果//Storing 9 to the address 0x7fff5fbff7b4//Storing 10.12 to the address 0x7fff5fbff7a8//3.0 meters is equal to 9 feet and 10.1 inches. Objective-C 基础学习自《Objective-C 编程》第二版，《Objective-C 基础教程》第二版，iTunes 上 Stanford iOS7 的视频。 类和方法初体验方法和消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546// main.c#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // date 类方法 class method // 类方法会创建类的实例 // 并创建实例变量 NSDate *now = [NSDate date]; NSLog(@"This NSDate object lives at %p", now); NSLog(@"The date is %@", now); // timeIntervalSince1970 实例方法 instance method // 提供实例中实例变量的信息，或是对实例变量进行操作 double seconds = [now timeIntervalSince1970]; NSLog(@"It has been %f seconds since the start og 1970.", seconds); // 方法带实参时，冒号时构成方法名的一个重要部分。 // 所以不存在 dateByAddingTimeInterval 方法 // 只有 dateByAdding-TimeInterval 方法 NSDate *later = [now dateByAddingTimeInterval:100000]; NSLog(@"In 100,000 seconds it will be %@.", later); NSCalendar *cal = [NSCalendar currentCalendar]; NSLog(@"My calendar is %@", [cal calendarIdentifier]); // 获取更多关于 NSDate 的信息 unsigned long day = [cal ordinalityOfUnit:NSCalendarUnitDay inUnit:NSCalendarUnitMonth forDate:now]; NSLog(@"This is day %lu of the month", day); // 消息的嵌套 double secondsNest = [[NSDate date] timeIntervalSince1970]; NSLog(@"It has been %f seconds since the start of 1970", secondsNest); // 练习：获取计算机的相关信息 // currentHost 类方法 NSHost *host = [NSHost currentHost]; // localizedName 实例方法 NSString *hostString = [host localizedName]; NSLog(@"This computer's name is %@.\n", hostString); &#125; return 0;&#125; alloc 和 init唯一必须以嵌套的形式连续发送的消息是alloc和init。 1234// NSDate *now = [NSDate date];NSDate *now = [[NSDate alloc] init];// 两种方法等价，使用 date 方法可以用最少的代码获取一个 NSDate 实例// 称这种方法为便利方法 convenience method 向 nil 发送信息nil是不指向任何对象的指针，多数面向对象的语言不允许向nil发送消息，但是在 Objective-C 中，可以向nil中发送消息，什么事情也不会发生。 重点1:如果程序向某个对象发送了消息，但是没有得到预期的结果，请检查消息接收方是否为nil。 重点2:向nil发送消息，得到的返回值没有意义。 idid 是可以指向任意类型对象的指针id 已经隐含了星号的作用。 获取从出生到当前时刻的时间间隔（单位：秒） 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSDateComponents *comps = [[NSDateComponents alloc] init]; [comps setYear:1997]; [comps setMonth:5]; [comps setDay:1]; [comps setHour:10]; [comps setMinute:10]; [comps setSecond:0]; NSCalendar *g = [[NSCalendar alloc] initWithCalendarIdentifier: NSCalendarIdentifierGregorian]; NSDate *dateOfBirth = [g dateFromComponents:comps]; NSDate *now = [NSDate date]; double secondsSinceEarlierDate = [now timeIntervalSinceDate:dateOfBirth]; NSLog(@"I have been living for %f seconds", secondsSinceEarlierDate); &#125; return 0;&#125; 对象和内存内存管理栈是由有序的帧构成的。函数的帧在函数结束后会自动释放。而堆里的对象不会自动释放。管理堆很重要，因为程序占用的堆大小是有限的。而每个对象被创建后都会占用一顶的堆内存。如果系统内存不足，Mac 应用的运行效果就会变差，而 iOS 应用则会崩溃。因此，必须释放不需要的对象，将内存交还给系统，继续重新使用。 1234567NSDate *currentTime = [NSDate date];NSLog(@"currentTime's value is %p", currentTime);sleep(2);currentTime = [NSDate date];NSLog(@"currentTime's value is now %p", currentTime); ARC第一个NSDate实例对象怎么样了？ 我们已经丢失了这个对象以及其包含的信息。因为我们丢失了指向该对象的指针，即使它仍然在堆上，我们也再不能获得这个对象的信息。如果要保留第一个 NSDate实例，需要在currentTime指向第一个实例时，创建新指针从currentTime那里获取第一个实例对象的地址，此时第一个实例对象的引用数为 2（该实例被 2 个指针所指向）。 将指向实例对象的指针设置为nil，实例对象就会失去一个引用，如果开启了 ARC，当一个实例对象的引用数为 0 时，就会自动销毁该实例对象，释放内存。 ARC automatic reference counting 自动引用计数 如果指针变量被销毁，它所指向的对象会失去一个引用。当某个对象的实例变量指向其他对象时，事情会变得更复杂—— todo NSString创建 NSString 实例1NSString *lament = @"Why me?"; 创建动态字符串，字符串的内容要等到程序运行时才能知道，可以使用stringWithFormat:类方法来创建动态字符串： 1NSString *datastring = [NSString stringWithFormat:@"The date is %@", now]; 使用官方文档打开 Xcode 的 “Help -&gt; Documentation and API Reference”,或者用快捷键 “Command + Shift + 0” ，搜索想了解的资料，注意语言的切换，可以先在顶部的搜索框输入某个类，再用 “Command + f” 在页面内搜索这个类的某个方法。 NSArray创建数组和遍历123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // 创建 3 个 NSDate 对象 NSDate *now = [NSDate date]; NSDate *tomorrow = [now dateByAddingTimeInterval:24.0 * 60.0 * 60.0]; NSDate *yesterday = [now dateByAddingTimeInterval:-24.0 * 60.0 * 60.0]; // 创建 1 个数组包含这 3 个对象 NSArray *dateList = @[now, tomorrow, yesterday]; // NSArray 实例一旦创建就无法改变， // 无法添加删除数组中的元素，也无法改变它们的位置 // 输出其中的两个对象 NSLog(@"The first date is %@", dateList[0]); NSLog(@"The third date is %@", dateList[2]); // 用 count 方法获取 dateList 指向的 NSArray // 对象的元素个数 NSLog(@"There are %lu dates", [dateList count]); // 遍历数组 NSUInteger dateCount = [dateList count]; for(int i = 0; i &lt; dateCount; i++) &#123; NSData *d = dateList[i]; NSLog(@"Here is a date: %@", d); &#125; // 快速枚举 for(NSDate *d in dateList) &#123; NSLog(@"Here is a date: %@", d); &#125; &#125; return 0;&#125; 可变数组 NSMutableArray1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // 创建 3 个 NSDate 对象 NSDate *now = [NSDate date]; NSDate *tomorrow = [now dateByAddingTimeInterval:24.0 * 60.0 * 60.0]; NSDate *yesterday = [now dateByAddingTimeInterval:-24.0 * 60.0 * 60.0]; // 创建空数组 NSMutableArray *dateList = [NSMutableArray array]; // 将 2 个 NSDate 对象加入新创建的数组 [dateList addObject:now]; [dateList addObject:tomorrow]; // 将 yesterday 指针插入到数组的起始位置 [dateList insertObject:yesterday atIndex:0]; // 快速枚举 for(NSDate *d in dateList) &#123; NSLog(@"Here is a date: %@", d); &#125; // 删除 yesterday 指针 [dateList removeObjectAtIndex:0]; NSLog(@"Now the first date is %@", dateList[0]); &#125; return 0;&#125; 旧式数组方法1NSArray *dateList = [NSArray arrayWithObjects:now, tomorrow, yesterday, nil]; 结束处的nil 告诉方法停止运行，所以，这个NSDate数列拥有三个指针对象。如果没有 练习购物清单123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; NSString *bread= @"Loaf of bread"; NSString *milk = @"Container of milk"; NSString *butter = @"Stick of butter"; NSMutableArray *shoppingList = [NSMutableArray array]; [shoppingList addObject:bread]; [shoppingList addObject:milk]; [shoppingList addObject:butter]; for(NSString *s in shoppingList) &#123; NSLog(@"Don't forget to buy %@", s); &#125; &#125; return 0;&#125; 里程碑 1：学会从问题出发查找 OC 文档在专有名词和常见名词表单中找到含”aa”的专有名词（即首字母大写）。 在给出的程序基础上，思考：如何判断首字母是否是大写，在NSString的界面搜索capital，发现没有相关方法，于是搜索index，想着应该有用index获取某个字符的方法，搜索得 1- (unichar)characterAtIndex:(NSUInteger)index; 于是将获取的字符与&#39;A&#39; 和&#39;Z&#39;比较一下就好了。 读入文件并将数据保存在字符串中的方法12345// 读入文件并将数据保存在字符串中// 没有处理可能发生的错误NSString *nameString = [NSString stringWithContentsOfFile: @"/usr/share/dict/words" encoding:NSUTF8StringEncoding error:NULL]; 然后贴一下完整的源码，打开的文件是在任意一台有 Mac OS 系统的人都有的文件，不必修改任何代码就可以运行。 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // 读入文件并将数据保存在字符串中 // 没有处理可能发生的错误 NSString *nameString = [NSString stringWithContentsOfFile: @"/usr/share/dict/words" encoding:NSUTF8StringEncoding error:NULL]; // 将所得字符串按"\n"进行分割，并保存在数组中 NSArray *names = [nameString componentsSeparatedByString:@"\n"]; // 枚举数组，一次处理一个字符串 for (NSString *n in names) &#123; // 查找字符串 "aa"（忽略大小写） NSRange r = [n rangeOfString:@"AA" options:NSCaseInsensitiveSearch]; // 是否找到 if (r.location != NSNotFound) &#123; // 获取每个单词的第一个字符 unichar firstChar = [n characterAtIndex:0]; if (firstChar &gt;= 'A' &amp;&amp; firstChar &lt;= 'Z') &#123; NSLog(@"%@", n); &#125; &#125; &#125; &#125; return 0;&#125; 里程碑2：第一个自定义类创建新类的步骤，Command + n，选择 macOS 区域中的 Cocoa class 点击 Next，填入类名，确定 Group 是存放源代码的文件夹，而不是整个项目，如下图 快捷键“Ctrl-Command-上箭头”，在 .m 文件及其对应的 .h 文件中切换。 在头文件中声明方法123456789101112131415161718192021// BNRPerson.h#import &lt;Foundation/Foundation.h&gt;@interface BNRPerson : NSObject&#123; // Step 0: BNRPerson 拥有两个实例变量 float _heightInMeters; int _weightInKilos;&#125;// Step1: 在花括号外声明 5 个实例方法- (float)heightInMeters;- (void)setHeightInMeters:(float)h;- (int)weightInKilos;- (void)setWeightInKilos:(int)w;// BNRPerson 类拥有计算 Body Mass Index 方法- (float)bodyMassIndex;@end 在 .m 文件中实现方法1234567891011121314151617181920212223242526272829303132333435// BNRPerson.m#import &lt;Foundation/Foundation.h&gt;#import "BNRPerson.h"@implementation BNRPerson// getter method- (float)heightInMeters&#123; return _heightInMeters;&#125;// setter method- (void)setHeightInMeters:(float)h&#123; _heightInMeters = h;&#125;- (int)weightInKilos&#123; return _weightInKilos;&#125;- (void)setWeightInKilos:(int)w&#123; _weightInKilos = w;&#125;- (float)bodyMassIndex&#123; return _weightInKilos / (_heightInMeters *_heightInMeters);&#125;@end 在 main()添加使用 BNRPerson 类的代码首先记得在 main.m 中导入头文件，当你打出 BNR… 还没有自动补全的提示，那么很可能是忘记了导入头文件。 123456789101112131415161718192021222324// main.c#import &lt;Foundation/Foundation.h&gt;#import "BNRPerson.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 创建 BNRPerson 实例 BNRPerson *mikey = [[BNRPerson alloc] init]; // 使用 setter 方法为实例变量赋值 [mikey setWeightInKilos:96]; [mikey setHeightInMeters:1.8]; // 使用 getter 方法打印出实例变量的值 float height = [mikey heightInMeters]; int weight = [mikey weightInKilos]; NSLog(@"mikey is %.2f meters tall and weights %d kilograms", height, weight); // 使用定制方法打印出 bmi 的值 float bmi = [mikey bodyMassIndex]; NSLog(@"mikey has a BMI of %f", bmi); &#125; return 0;&#125; 存取方法及命名getter 和 setter 方法被统称为存取方法 accessor method 或 accessor。 实例变量的命名方法是：开头是下划线，然后是小写开始的驼峰命名法。 方法不以下划线开头，存方法以 set 开头，取方法名和实例变量名相同（只是没有下划线）。 特别需要注意的是，Objective-C 中没有命名空间，所以如果你写了一个称为 Person 的类，而它连接到另一个库，其中有其他人声明的 Person 类，编译器无法区别这两个类，就会出现编译器错误。 为了避免这样的冲突，苹果公司推荐使用三个或三个以上字母作为类的前缀，让类的名字独一无二，就不会和其他人的类名起冲突。 selfObjective-C 的方法都包含一个隐含的局部变量self，它是一个指向当前方法的对象的指针。当某个对象要向自己发送消息的时候，就需要使用self。有些人坚持不直接存取实例变量（个人认为是为了避免不小心修改实例变量）的信条，他们会在类的方法中调用对象自身的存取方法。改写一些上文中的bodyMassIndex方法： 12345- (float)bodyMassIndex&#123; float h = [self heightInMeters]; return [self weightInKilos]/(h*h);&#125; Properties可简化存取方法的过程。 Declaring properties在 BNRPerson.h 中删除实例变量，然后用下面两个属性heightInMeters和weightInKilos重写存取方法的声明。 12@property (nonatomic) float heightInMeters;@property (nonatomic) int weightInKilos; 声明属性的时候，编译器还会帮你声明存取方法。不过有一些例外情况，需要自己调整属性声明或实现存取方法。 Property attributes nonatomic atomic (default) readonly readwrite 例如： 123456@property (nonatomic, readonly) double circumferenceOfEarth;// 属性要么是只读属性// 要么是读/写 (readwrite) 属性@property (nonatomic, readwrite) double humanPopulation; Dot notation使用 dot notation 的时候是在发送消息。 123mikey.weightInKilos = 96;// ...float height = mikey.heightInMeters; Inheritance创建一个新类，命名为 BNREmployee，还记得怎么创建新类吗？如果不记得，查看左边的目录，点击“里程碑2:第一个自定义类”再复习一下(・ω・)ノ 在 BNREmployee.h，导入 BNRPerson.h，将父类从 NSObject 改为 NSRPerson 12345678910111213// BNREmployee.h#import "BNRPerson.h"@interface BNREmployee : BNRPerson@property (nonatomic) unsigned int employeeID;@property (nonatomic) unsigned int officeAlarmCode;@property (nonatomic) NSDate *hireDate;- (double)yearOfEmployment;@end 在 BNREmployee.m 文件中，实现 yearOfEmployment 方法： 123456789101112131415161718#import "BNREmployee.h"@implementation BNREmployee- (double)yearOfEmployment&#123; // 是否拥有一个非 nil 的 hireDate ？ if (self.hireDate) &#123; NSDate *now = [NSDate date]; NSTimeInterval secs = [now timeIntervalSinceDate:self.hireDate]; return secs / 31557600.0; // 每年的秒数 &#125; else &#123; return 0; &#125;&#125;@end 在 main.m 中导入 BNREmployee.h，创建一个 BNREmployee 的实例。让 mikey 变量指向一个 BNRPerson 对象。 1234567891011121314151617181920212223242526272829303132333435//// main.m// BMI//// Created by rooooooot on 12/10/16.// Copyright © 2016 VectorLu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import "BNRPerson.h"#import "BNREmployee.h"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 创建 BNRPerson 实例 BNREmployee *mikey = [[BNREmployee alloc] init]; // 使用 setter 方法为实例变量赋值 mikey.weightInKilos = 96; mikey.heightInMeters = 1.8; mikey.employeeID = 12; mikey.hireDate = [NSDate dateWithNaturalLanguageString:@"Aug 2nd, 2010"]; // 使用 getter 方法打印出实例变量的值 float height = mikey.heightInMeters; int weight = mikey.weightInKilos; NSLog(@"mikey is %.2f meters tall and weights %d kilograms", height, weight); NSLog(@"Employee %u hired on %@", mikey.employeeID, mikey.hireDate); float bmi = [mikey bodyMassIndex]; double years = [mikey yearOfEmployment]; NSLog(@"BMI of %.2f, has worked with us for %.2f years", bmi, years); &#125; return 0;&#125; Overriding methods通常，子类会与父类有所不同。假设，员工的 BMI 值都是 19.在这种情况下，可以覆盖BNREmployee的bodyMassIndex方法。 可以编写一个新的实现来覆盖继承下来的方法。在BNREmployee.m方法中，覆盖bodyMassIndex： 1234- (float)bodyMassIndex&#123; return 19.0;&#125; Inheritance hierarchyNSObject]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode 使用笔记 0 新司机上路]]></title>
      <url>%2F2016%2F11%2F29%2Fusing-Xcode-0%2F</url>
      <content type="text"><![CDATA[Xcode 是苹果家官方 IDE，颜值非常高，界面也挺复杂，偶然在学校图书馆发现一本 《Xcode 江湖录》，结合自己学习 OC 和以往使用 Xcode 的一些经验写写 Xcode 的使用笔记。希望能对看到这个系列文章的同学有所帮助，当然包括记性不好的我自己：）如有谬误，请不吝赐教。 使用的版本是 8.1。 欢迎界面一般第一次打开 Xcode 都会有一个如下的欢迎界面。 界面右端列举了最近使用过的项目，方便快速打开常用项目。如果要打开的项目不在这个列表中，可以点击列表下面的 “Open another project…”。 如果不想再看到这个欢迎界面，可以取消勾选左下方的 “Show this window when Xcode lauches”。不建议取消勾选。但是如果你取消勾选了之后又想要打开 Xcode 的欢迎界面，那么依次选择菜单栏上的 “Window -&gt; Welcome to Xcode” 即可，或者直接使用⌘+⇧+1(“Command + Shift + 1”) 快捷键。 Playground就是一个让你玩 Swift 的地方，能够即时得到你的代码结果，不过功能有限。 创建项目填入相关信息及说明单击 “Create a new Xcode project” ，弹出一个项目模板选择窗口如下图，由于版本问题，你看到的窗口可能和我不一样，但是基本上都非常类似。 选择 “OS X” -&gt; “Application” -&gt; “Command Line Tool”。然后填入： 项目名称（Product Name） 组织名称（Organization），嗯，你可以填入你的公司名称，哪怕公司现在只有你一个光杆司令：） 组织标识符（Organization Identifier）。必须是 DNS 的逆序，然后是你的名字（比如我的是 com.vectorlu.Victoria)，这个东西是你将 App 发布到 App Store 之后，App Store 用来标志你身份的东西，所以必须是独一无二的。由于 DNS 在网络上往往是独一无二的，所以这种方式是一种普遍的标志方式，Android 也是这样的。当然，你现在可能没有 Organization Identifier ，可以填入 com.example.yourname，想了解更权威的说明，可以戳这里：苹果官方的说明。 有 4 种语言可以选择，选择你熟悉的语言就好，笔者同时在学习 Objective-C，如果你在学习 C 语言，选择 OC 或 C 都没关系，因为 OC 完全兼容 C 语言。不过 OC 的后缀名是.m，代码的模版和 C 语言不同。 不推荐数字作为项目名称的首字母，也不推荐用特殊字符来命名项目名称和组织标识符。因为如果这样做，下面的包标识符 (Bundle Identifier) 会用-来代替不符合规范的字符，可能给上传应用带来麻烦。 组织标识符和包标识符都是用来唯一确定应用身份的标识符，已经创建后最好不要修改，以免带来一些不必要的麻烦。 在哪里写代码？初次创建完项目后，新司机可能会被 Xcode 复杂的界面吓到，而且如果没有汉化，英语不好的新司机更是感觉很头大。无论如何，Xcode 的颜值还是挺高(((o(*ﾟ▽ﾟ*)o)))。要如何同这个高颜值的 IDE 玩耍呢？ 这个窗口有很多信息，但实际上不需要这么多，简化一下。右上角我框起来的地方有三个按钮，用来隐藏或显示窗口中的不同区域。比如最右边的蓝色按钮，表示右侧栏正在显示，点一下就变灰了，说明右侧栏被隐藏。 窗口右侧栏的信息暂时用不上，先隐藏。好了，现在窗口上左端是导航区 (Navigator Area)，右端是编辑区 (Editor Area)。点一下左侧的main.m就可以在右端的编辑区中开始编辑代码了，如果双击 Xcode 会打开一个新的窗口。快捷键 Command + r，或者单击左上角的类似于播放键的按钮，就可以运行程序了。 运行成功的标志，如果失败了就是 Failed 下图是 Xcode 的调试区域，可以查看代码运行的结果和一些出错信息。如果没有出现这个控制台窗口，那么依次点击 “View -&gt; Debug Area -&gt; Activate Console” 打开调试区域，或者直接使用快捷键 Command + Shift + c直接打开。 导入库在 Xcode 中，比如要使用readline()函数，需要先添加包含这个函数的库类，关于 readline类库。 在左端的项目导航中，点击顶层的项目 “HelloXcode”。在右端编辑区域中，点击 Build Phases 后展开 Link Binary With Library 的三角格式说明符。点击 + 按钮，如下图： 然后表单会展开，显示可用的代码库清单。使用搜索栏 search box 搜索 libreadline。表单中显示它时，选择并点击添加按钮。然后在代码中加上#import &lt;readline/readline.h&gt;就可以使用readline()函数了。 移除项目在 Finder 中删除找到项目所在的地方直接删除就好。但是这种方法会在 Xcode 中留下一些残余的缓存文件。不过一般没有什么影响。 在 Xcode 中彻底删除在屏幕最上方的菜单栏中点击 “Window -&gt; Projects”，选中刚刚删除的项目，然后点击右上角的 Delete 或者左下角的小齿轮，选择 “Remove from Projects” 选项，就可以清除这些缓存文件。 这次就说到这里，新司机萌，上路愉快：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C_Compiler_by_C]]></title>
      <url>%2F2016%2F11%2F28%2FC-Compiler-by-C%2F</url>
      <content type="text"><![CDATA[编译原理基础知识总结 CH1 编译概述TODO CH2 文法和语法的基础知识TODO:6 文法和语言的分类0 型文法（无限制文法）关键在于𝜷可以为空 1 型文法（上下文有关文法）1𝜶𝑨𝜷 → 𝜶𝑢𝜷 2型文法（上下文无关文法）CH3 词法分析与有穷自动机词法分析程序的功能对字符串表示的源程序从左到右进行扫描和分解，根据语言的词法规则识别出一个一个具有独立意义的单词符号。 单词符号及输出单词的形式词法分析程序的： 输入：字符串形式的源程序 输出：单词符号 or 单词符号表示的源程序 语言的单词符号 token语言中具有独立意义的最小语法单位，分为以下 5 种： 关键字if else while do 等 标识符,比如变量名、常量名、数组名、函数名等等 常数，比如 整型常数 125 实型常数 0.718 布尔型常数 TRUE 等等 运算符+ - * / &lt; 等等 界符, ; ( ) : 等等 一个程序语言的关键字、运算符和界符的个数是确定的，而对于标识符或常数的使用个数通常是不确定的。 词法分析程序输出单词的形式二元式： 1（单词种别，单词自身的值） 单词种别单词种别表示单词的种类，是语法分析需要的信息。 一个语言的单词符号如何划分种类、分成几个种类、怎样编码，取决于处理方便。通常让每种单词对应一个整数码，最大限度地把各个单词区别开。 关键字：全体视为一种，但一般一字一种（个数确定） 运算符：同关键字 界符：同关键字 标识符：统归为一种 常数：可按类型（整型、实型、布尔型等等），也可统归为一种，比如 1(+|-|ɛ)dd*(.dd*|ɛ)(e(+|-|ɛ)dd*|ɛ) 单词自身的值单词自身的值是编译中其他阶段所需要的信息。 用以下方法确定其值： 如果一个种别只含一个单词符号，那么对于这个单词符号，种别编码完全代表其自身的值。 如果一个种别又多个单词符号，那么对于它的每个单词符号，除了给出种别编码之外，还应 给出单词符号的自身值，以便把同一种类的单词区分开来。 标识符的自身值：标识符自身的字符串 常数自身值：常数本身的二进制数值 用指向某类表格中一个特定项目的指针值来区分同类中不同单词 标识符：在符号表的入口指针作为它自身的值 常数：在常数表的入口指针作为自身值 假设关键字、运算符和界符都是一符一种，标识符自身的值用自身的字符串表示，常数自身的值用标准二进制形式表示，则程序段if (a &gt; 1) b = 100;在经词法分析程序扫描后，它所输出的单词符号串是： 二元式 表示的意义 (2, ) 基本字if (29, ) 左括号( (10, ‘a’) 标识符a (11, ‘1’的二进制) 常数1 (30, ) 右括号) (10, ‘b’) 标识符b (17, ) 赋值号= (11, ‘100’的二进制) 常数100 (26, ) 分号; 其中，假设标识符种类编码为整数 10，常数的种类编码为整数 11，基本字if种类编码为 2，赋值号种类编码为…… 语言单词符号的两种定义方式 正规文法 正规式 TODO CH4 语法分析文法的左递归性和回溯的消除在自上而下分析过程中，为了避免回溯，即要求描述语言的文法是 LL(1) 文法。 LL(1) 文法的判断条件1设 𝜶 TBC 预测分析法与预测分析表的构造方法 计算文法 G 的每一非终结符的 FIRST 集和 FOLLOW 集。 对文法的每个规则 𝑨⟶𝛼，若a ∈ FIRST(𝛼)，则置 M[A, a] = 𝑨⟶𝛼，显然其中 a 是终结符。 若 𝜺 ∈ FIRST(𝛼)，则 ∀ b ∈ FOLLOW(A)，则置 M]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去掉 mac 终端下长长的电脑名和用户名]]></title>
      <url>%2F2016%2F11%2F27%2Fremove-long-pc-user-name%2F</url>
      <content type="text"><![CDATA[在 Linux 或 macOS 下用 bash 的时候，当然如果你是 zsh 用户，一般不会有这种困扰——终端每一行前面有好长的一串——“本机名 当前路径 用户名”，再是表示等待输入指令的$。在 bash 下要如何去掉这些冗长的信息呢？ 在终端下进入/etc目录，这个目录是类 Unix 系统存放一些零碎的系统配置文件的文件夹。 用文本编辑器打开bashrc，我习惯用 Atom 。 1$ atom /etc/bashrc PS1: 控制默认命令行提示符的格式。在终端下用echo $PS1命令显示当前提示符设置。 Richard BlomLinux 命令行与 Shell 脚本编程大全第2版 所以，修改bashrc文件中的PS1的值就可以了 ‘\h’ 指的是主机‘\W’ 指的是当前工作目录‘\u’ 指的是当前用户 修改成你喜欢的样子就好了，一般保留\W。该方法来自这个博客中去掉（隐藏）mac终端前面的计算机名 ta 的博客中 20161028的那一篇。那篇博文的 URL 有问题，黏贴过来之后无法正常访问 Orz 。 效果如下 感谢 liuxiaojia 这位朋友的提醒。 同时，诚恳建议 Hexo 博客的文件名中不要包涵特殊的中文符号，比如中文括号，给正确复制博客网址带来了莫大的困难 Orz 。建议新建 Hexo 博客可以全部用英文，Hexo 生成博客的 URL 完全根据文件名生成，中文在复制过程中容易乱码，中文符号也会带来一些麻烦 Orz 。参考博客的 URL 就是因为包含中文括号，所以在复制 URL 后无法访问到正确的地址。 博客的题目title字段就无所谓了，对中文及相关符号很友好。Hexo 会自动设置为文件名，但是可以手动修改，不会影响 URL，设置成你喜欢的中文名就好了。 如下图，文件名用英文，生成 md 文件后把题目手动改成中文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo_4_NexT_Pisces_主题配置细节]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-4-theme-NexT-Pisces-details%2F</url>
      <content type="text"><![CDATA[待完成 Orz 安装]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo_3_写作与更新的细节]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-3-writing-update-blog%2F</url>
      <content type="text"><![CDATA[基本操作就是根据Hexo官方文档NexT官方文档来配置一些细节，在这里用图文记录一下具体过程和比较常用的命令。 写作创建新文章1$ hexo new [layout] &lt;title&gt; 创建了新文章之后打开，会在文章开头看到类似以下内容的东西。 123456789---title: 使用 Hexo 搭建博客的细节配置 1date: 2016-11-26 00:03:44categories:- KITtags:- blog- hexo--- 这个部分是用来指定该文章的各种变量哒： 参数 描述 默认值 layout 布局 title title date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页) permalink 覆盖文章网址 － 只有文章支持分类和标签，page 不支持，标签没有顺序和层次。 引用md 本身有自己的引用语法 这是第一行引用这是第二行引用引用方式非常简单，但是引用的样式比较单一，如果要显示引用源的相关信息就力不从心了。 以下来自标签插件，摘录到本地方便查阅。 引用网络上的文章123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125; 效果： Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 引用 Twitter123&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http://devdocs.io&#123;% endblockquote %&#125; NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用书上的句子123&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 没有提供参数，则只输出普通的 blockquote123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 创建新页面比如新建about页面 1hexo new page about 服务器hexo-server安装1$ npm install hexo-server --save 启动安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。1$ hexo server 或 1$ hexo s 更改端口想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000 生成文件hexo generate 或 hexo g 完成后部署执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。 12$ hexo generate --deploy$ hexo deploy --generate 部署详见 多语种支持在站点配置文件 _config.yml 中修改 new_post_name 和 permalink 参数，如下： 12new_post_name: :lang/:title.mdpermalink: :lang/:title/ 建立新文章时，文章会被存储到： 12$ hexo new "Hello World" --lang tw# =&gt; source/_posts/tw/Hello-World.md 而网址会是http://localhost:4000/tw/hello-world/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-2-用 Coding Pages 部署 Hexo 博客]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-2-coding-pages%2F</url>
      <content type="text"><![CDATA[待完成 Orz]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-1-用 Github Pages 部署 Hexo 博客]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-1-github-pages%2F</url>
      <content type="text"><![CDATA[安装好了 Hexo，下一步就是：将自己的博客放到网上，让每个人都能访问。 介绍一下如何用 Github 的 Pages 服务来支持静态博客。如果你对 Git 还不熟悉，那么建议你先阅读一下（不阅读也没有关系，因为 Hexo 不需要太多 Git 的知识）：廖雪峰的Git教程 Step-0-注册Github在 Github官网 中 sign up 就好了。 Step-1-管理远程仓库相关命令概览与说明其实用不到这么多 git 的知识，只是顺带介绍一下，可跳过。 1234567891011121314151617ssh-keygen -t rsa -C ("youremail@example.com")#创建ssh keygit remote add origin (repository address on github)#关联远程仓库git remote -help #用来查看帮助git push -u origin master#第一次推送本地内容到远程仓库要加 -u参数git push origin master#以后就可以直接推送内容了git clone (repository address on github)#将repository克隆到本地 添加远程仓库 SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 创建SSH Key在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C "youremail@example.com" 需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 用文本编辑器打开 id_rsa.pub ，比如atom（如果安装了atom），vi等 也可以用这样方法打开id_rsa文件如果没有安装atom，可以用vi打开$ vi id_rsa 登陆Github打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：点“Add Key”，你就应该看到已经添加的Key：以上两张图片来自廖雪峰的git教程 测试一下 1ssh -T git@github.com 可能会有警告，不过没关系，输入yes就好。 在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 添加 Repository首先，登陆GitHub，然后，在右上角找到一个加号，点击“ New repository”按钮，创建一个新的仓库，仓库名用username.github.io。比如我的用户名是VectorLu，那么新建的仓库名（Repository name）就是VectorLu.github.io。 下面的 Description 随便写就好了，比如写 My blog repository. 其他的都不用管，点下面的绿色按钮Create repository就好了。 Step-2-部署本地的 Hexo 博客到 Github还记得在 Hexo-0 中用 hexo init foldname 那个文件夹吗？进入文件夹，用文本编辑器打开_config.yml，我习惯用atom打开，或者用自带的vi打开也可以。 也许你没有atom，也不会用vim。那就在Finder中找到这个文件，双击，应该会默认用Xcode打开。 用command+f快捷键，或者直接在这个文件的最后（一般是放在最后）找到deploy字段。修改成如下样式，注意把所有 VectorLu 换成你的 Github 用户名。 12345deploy: type: git repo: github: git@github.com:VectorLu/VectorLu.github.io.git branch: master 保存，进入终端。 1234$ npm install hexo-deployer-git --save # 安装相关组件$ hexo clean$ hexo g$ hexo d 应该一会就部署好了，在浏览器中输入username.github.io就可以访问你的博客了。如果没有刷出来，可能是网络问题，多等一会就可以刷出来了。 Step-3-绑定个人域名（非必需）有很多网站出售域名，比如万网。 //TODO: !!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo_0_Mac 下搭建自己的博客图文详解]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-0-mac-build-blog%2F</url>
      <content type="text"><![CDATA[Hexo 安装与建站分享一下 2016-11 在 Mac 下使用 Hexo3 &amp; github &amp; coding &amp; 万网 搭建博客的经验、技巧、注意事项。 用 Hexo 建站命令行概览注意！HexoBlogFolder这个文件名仅作为提示，选择任何你喜欢的文件名就好，以后这个文件夹中包含所有部署博客的相关文件，你也会在这个文件夹里存放你的思想结晶博客。 12345$ hexo init HexoBlogFolder$ cd HexoBlogFolder$ npm install$ hexo g # 等于 hexo generate$ hexo s # 等于 hexo server Hexo 安装安装 Hexo 时常容易出问题，原因一般是没有sudo授权。以前装过 Hexo，感觉麻烦不少，老是报错，但是这次（20161124），正好在 Hexo 重大更新到 Hexo3 之后，安装过程还比较顺利。需要注意的是：在 macOS 和 Linux 下 Hexo 安装时需要root权限，官方文档上给出的命令行没有用sudo实在有点坑 Orz。不过官方文档还是得看看，毕竟是最权威的资料，虽然有时候不够详细。 Step0-Git 安装首先需要有Git，如果已经安装 Xcode ，那么Git应该已经安装好了。因为 Hexo 需要用到 Xcode，所以在 AppStore 中下载安装就好了。如果不确定mac上是否有Git，可以在命令行中输入git --version查看。 如果已经安装，会显示出Git的版本。 如果没有安装，可以用多种方法安装，比如安装程序、Homebrew 安装。 Step0-Node.js 安装个人认为最好是用 Node.js 的官网安装包直接安装。一直确定就好了。 Step1-Hexo 安装官网上给出的命令行在 mac 上应该不能成功安装 Hexo $ npm install -g hexo-cli 需要使用： 1$ sudo npm install -g hexo-cli 没有什么 error 应该就没问题了。 Step2-Hexo 建站用终端cd到你喜欢的位置，比如cd Document然后执行下列命令，Hexo 会在~/Document/下新建所需文件 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 比如我就在~下新建了myBlog文件夹 123~ $ hexo init myBlog$ cd myBlog$ npm install Hexo 就安装好了，再执行 12$ hexo generate$ hexo server 上述命令也可以写作 12$ hexo g$ hexo s 就可以生成博客所需的文件，并启动本地服务器。 打开本地浏览器，在地址栏输入 localhost:4000，如下图，就能看到 Hexo 的 Hello World 界面。当然你的界面和我的还不一样，不过别着急，你马上就可以配置自己的个性界面了：） 安装主题 NexT逛了一圈 Hexo 的主题，每种主题都有各自的惊艳之处和不足之点。也打算自己写个主题，但是看了一下日程表，大概一年内都没有时间学习开发，关键是之后的文档支持和维护，都有点麻烦。 最后就选择了 NexT 的 Pisces。 在终端下进入之前用 Hexo 初始化的文件夹，比如我的是 myBlog，cd myBlog然后： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 进入myBlog文件夹，找到_config.yml（这个目录下的这个文件是站点配置文件），用 Xcode 或者文本编辑器打开，找到 theme 字段，修改成（注意冒号和 next 之间有一个空格。 1theme: next 进入theme文件夹，进入next文件夹，找到_config.yml（这个目录下的是NexT主题配置文件），找到 Schemes 字段，有三种主题可供选择，比如我个人比较喜欢 Pisces 1234# Schemes#scheme: Muse#scheme: Mistscheme: Pisces 在终端进入myBlog文件夹 123$ hexo clean$ hexo g$ hexo s 打开浏览器，输入http://localhost:4000/就会看到 Pisces 主题的界面了。 当然还有很多细节需要配置，我在后面的博文中也会陆续分享自己的经验。如果有好的建议，请不吝赐教。 Hexo官方文档NexT官方文档]]></content>
    </entry>

    
  
  
</search>
