<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[C 语言存储类详解]]></title>
      <url>%2F2016%2F11%2F30%2FC-5-storage-class-specifiers%2F</url>
      <content type="text"><![CDATA[如果对以下问题有疑惑，不妨看看全文。 在编写多文件的 C 语言程序时，在 C 源文件中使用了同名的变量时，应该如何保护有些变量不被意外修改？ 究竟需要初始化变量吗？什么时候，应该如何，初始化什么种类的变量？ 静态变量 static variable 中的静态究竟指什么？是指值不能改变吗？ 一个 C 语言变量会存放在哪里，可以指定它的存放位置吗？ 为什么有些算法书建议，将很大的数组放在所有函数之外声明？ 由于要写 C 语言编译器，整理一下 C 语言中不太清楚的知识。 C 语言中有 5 个作为存储类说明符 (storage class specifier) 的关键字，它们是auto register static extern以及typedef。 本文主要摘自 《C Primer Plus》第 12 章。 存储类、链接和内存管理C 使用作用域、链接和存储时期来定义 5 种存储类，首先来认识一下这三个术语。 作用域——程序中可以访问一个标识符的一个或多个区域。 代码块作用域 block scope在代码块（一对花括号中包含的代码）中定义的变量具有代码块作用域，从该变量被定义的地方到相应代码块的结尾，该变量均可见。 另外，函数的形式参量尽管在函数的开始花括号前进行定义，同样也具有代码块作用域，隶属于包含函数体的代码块。 下列代码中变量 cleo 和 patrick 都有直到结束花括号的代码块作用域。 123456double blocky(double cleo)&#123; double patrick = 0.0; ... return patrick;&#125; 在一个内部代码代码块中声明的变量，其作用域只局限于该代码块： 12345678910111213double blocky(double cleo)&#123; double patrick = 0.0; int i; for (i = 0; i &lt; 10; i++) &#123; double q = cleo * i; // q 作用域的开始 ... patrick *= q; &#125; // q 作用域的结束 ... return patrick;&#125; 在这个例子中，q 的作用域被限制在内部代码块内，只有该代码块内的代码可以访问 q。 C99 之前（你用的 Xcode 完全支持 C99），具有代码作用域的变量都必须在代码块开始处进行声明，C99 开始允许在一个代码块中任何位置声明变量。 12for (int i = 0; i &lt; 10; i++)&#123;printf("A C99 feature: i = %d", i);&#125; 作为这一新功能的一部分，C99 把代码块的概念扩大到包括由 for循环、while 循环或者if语句所控制的代码——即使这些代码没有用花括号括起来。 文件作用域 file scope一个在所有函数之外定义的变量具有文件作用域。具有文件作用域的变量从它定义处到包含该定义的文件 结尾处都是可见的。除非被同名的局部变量屏蔽。 函数原型作用域 function prototype scope适用于函数原型中使用的变量名。函数原型作用域从变量定义处一直到原型声明的末尾。这意味着编译器在处理一个函数原型的参数时，它所关心的只是该参数的类型。名字通常是无关紧要的，名字起作用的一种情形是变长数组参量： 1void use_a_VLA(int n, int m, ar[n][m]); 如果在方括号中使用了变量名，则该变量名必须是在原型中已经声明了的。 链接，一个 C 变量具有下列链接之一：外部链接 external linkage具有外部链接的变量可以在一个 多文件程序 的 任何 地方使用。 内部链接 internal linkage在定义时使用了存储类说明符static，可以在定义该变量的文件的任何地方使用。 空链接 no linkage具有代码块作用域和函数原型作用域的变量有空链接。意味着它们由其定义所在的代码块或函数原型所私有。 1234567int giants = 5; // 文件作用域，外部链接static int dodgers = 5; // 文件作用域，内部链接int main()&#123; int i = 0; // 空链接 ...&#125; 存储时期一个 C 变量有以下两种存储时期之一： 静态存储时期 static storage duration 具有文件作用域的变量，具有静态存储时期。 注意对于具有文件作用域的变量，关键词 static 表明链接类型，并非存储时期。一个使用 static 声明了的文件作用域变量具有内部链接，而所有文件作用域变量，无论它是具有内部链接，还是具有外部链接，都具有静态存储时期。 在函数内，定义时，声明为 static 的变量。 自动存储时期 auto storage duration在代码块内，在定义时，没有用关键字static声明的变量具有自动存储时期。在程序进入定义这些变量的代码块时，将为这些变量分配内存；当退出这个代码块时，分配的内存将被释放。该思想吧自动变量使用的内存视为一个可以重复使用的工作区或者暂态内存。例如，在一个函数调用结束后，它的变量所占用的内存可以被用来存储下一个被调用函数的变量。 5 种存储类C 使用作用域、链接和存储时期来定义 5 种存储类，见下表： 存储类 存储时期 作用域 链接 声明方式 自动 自动 代码块 空 代码块内 寄存器 自动 代码块 空 代码块内，使用 关键字 register 空链接的静态 静态 代码块 空 代码块内，使用关键字 static 具有外部链接的静态 静态 文件 外部 所有函数之外 具有内部链接的静态 静态 文件 内部 所有函数之外，使用关键字 static 自动变量可用关键字 auto显示定义存储类型。 默认情况下，在代码块或函数的头部定义的任意变量（没有用 static 显示声明）都属于自动存储类。 1234int main(void)&#123; auto int plox;&#125; 再来仔细看一下嵌套代码块。只有定义变量的代码块及其内部的任何代码块可以访问这个变量，这是一个： 1234567891011int loop (int n)&#123; int m; // m 的作用域 scanf("%d", &amp;m); for (int i = m; i &lt; n; i++) &#123; // m 和 i 的作用域 puts("i is local to a sub-block\n"); &#125; return m; // m 的作用域，i 已经消失&#125; 变量 i 仅在内层花括号中可见，如果试图在内层代码块之前或之后使用该变量，将得到一个编译错误。变量 n 和 m 在函数头部和外层代码块中定义，在整个函数中可用，一直存在到函数终止。 如果在内层代码块定义了一个具有和外层代码块变量同一名字的变量，内层定义会暂时覆盖 (hide) 外部定义，但是当运行离开内层代码块时，外部变量重新恢复作用。 不带{}的代码块在 C99 中，语句若为循环或者 if 语句的一部分，即使没有使用{}，也认为是一个代码块，和内层花括号的效果一样。 ⚠️注意：有些编译器可能不支持 C99 作用域规则，其他编译器可能提供一个激活这些规则的选项。例如用 gcc 在命令行下编译filename.c这个文件，需要使用gcc -std=c99 filename.c -o filename 自动变量的初始化除非显示地初始化自动变量，否则它不会被自动初始化。考虑如下声明： 123456int main(void)&#123; int repid; int tents = 5; ...&#125; 变量tents初始化为 5，而变量repid的初值则是，先前占用分配给它的空间的任意值。不要指望这个值是 0。 寄存器变量可以用存储类说明符register声明寄存器变量。 12345int main(void)&#123; register int quick; ...&#125; 如果幸运，寄存器变量可以被存储在 CPU 寄存器中，或者存储在速度最快的可用内存中，从而可以比普通变量更快地被访问和操作。因为寄存器变量多是存在一个寄存器而非内存中，所以无法获得寄存器变量的地址。但是在其他的许多方面，寄存器变量域自动变量一样——都有代码块作用域、空链接以及自动存储时期。 之所以说“如果幸运”，是因为声明一个寄存器变量仅是一个请求，而非一条直接的命令。编译器必须在您的请求与可用寄存器的个数或可用高速内存的数量之间做权衡，所以您可能达成不了自己的愿望。这种情况下，变量称为一个普通的自动变量；然而，您依然不能对它使用地址运算符。 可以使用register声明的类型是有限的。例如，处理器可能没有足够大的寄存器来容纳 double类型。 具有代码块作用域的静态变量通过使用存储类说明符static（这提供了静态存储时期）在代码块内声明（这提供了代码块作用域和空链接）创建。 静态变量 (static variable)中“静态”是指变量的位置固定不动。 具有文件作用域的变量自动（也是必须的）具有静态存储时期。也可以创建具有代码块作用域，兼具静态存储的局部变量。也就是说，从一次函数调用到下一次调用，计算机都记录着它们的值。 1234567891011121314151617181920212223#import &lt;stdio.h&gt;void trystat(void);int main(int argc, const char * argv[])&#123; int count; for(count = 1; count &lt;= 3; count++) &#123; printf("Here comes iteration %d: \n", count); trystat(); &#125; return 0;&#125;void trystat(void)&#123; int fade = 1; static int stay = 1; printf("fade = %d and stay = %d\n", fade++, stay++);&#125; 运行结果为： 1234567Here comes iteration 1: fade = 1 and stay = 1Here comes iteration 2: fade = 1 and stay = 2Here comes iteration 3: fade = 1 and stay = 3Program ended with exit code: 0 静态变量stay记得它的值曾被加 1，而变量fade每次都重新开始。这表明初始化的不同：在每次调用trystat()时fade都被初始化，而stay只在编译trystat()时被初始化一次。 如果不显式地对静态变量进行初始化，它们将被初始化为 0。以下两个声明看起来很相似： 12int fade = 1;static int stay = 1; 然而，第一个语句确实是函数trystat()的一部分，每次调用该函数时都会执行它——运行时动作。而第二个语句不是该函数的一部分。如果用调试程序逐步运行改程序，会发现，程序看起来跳过了那一步。那是因为静态变量和外部变量在程序调入内存时已经就位了。把这个语句放在trystat()函数中是为了告诉编译器只有函数trystat()可以看到该变量。它不是在运行时执行的语句。 对函数参量不能使用static 1int wontwork(static int flu); // 不允许 具有外部链接的静态变量具有外部链接的静态变量具有文件作用域、外部链接和静态存储时期。这一类型被称为外部存储类 (external storage class)，这一类型的变量称为外部变量 (external variable)。 把变量的定义声明放在所有函数之外，即创建了一个外部变量。为了使程序更加清晰，可以在使用外部变量的函数中通过使用extern关键字来再次声明它。 如果变量是在别的文件中定义的，使用extern来声明该变量就是必须的。 12345678910int Errupt; // 外部定义的变量double Up[100]; // 外部定义的数组// 必须的声明，因为 Coal 在其他文件中定义extern char Coal; int main(void)&#123; ...&#125; 外部变量初始化如果不对外部变量进行初始化，它们将自动被赋初值 0。这一原则也适用于外部定义的数组元素。不同于自动变量，只可以用常量表达式来初始化文件作用域变量: 1234int x = 10; // 可以，10 是常量int y = 3 * 20; // 可以，一个常量表达式size_t z = sizeof(int); // 可以，一个常量表达式int x2 = 2 * x; // 不可以，x 是一个变量 （只要类型不是一个变长数组，sizeof 表达式就被认为是常量表达式。） 外部名字C99 标准要求编译器识别局部标识符的前 63 个字符和外部标识符的前 31 个字符。 定义和声明12345int tern = 1; // 定义 tern main()&#123; external int tern; // 使用在其他地方定义的 tern 变量 这里，tern 第一次声明为变量留出了存储空间，它构成了变量的定义。第二次声明只是告诉编译器要使用先前定义的变量 tern，因此不是一个定义。第一次声明称为定义声明 (definig declaration)，第二次声明称为引用声明 (referencing declararion)。关键字 extern 表明该声明不是一个定义，因为它指示编译器参考其他地方。 如果这样做： 123extern int tern;int main(void)&#123; 那么编译器假定 tern 的真正定义是在程序中其他某个地方，也许是在另一文件中。这样的声明不会引起空间分配。因此，不要用关键字 extern 来进行外部定义；只用它来引用一个已经存在的外部定义。 一个外部变量只可进行一次初始化，而且一定是在变量被定义时进行。下面的语句是错的：extern char permis = &#39;Y&#39;; // 错误 因为关键字extern的存在标志着这是一个引用声明，而非定义声明。 使用复杂的 C 程序往往使用多个独立的代码文件。有些时候，这些文件可能需要共享一个外部变量。ANSI C 通过在一个文件中定义变量，在其他文件中引用声明这个变量来实现共享。也就是说，除了一个声明（定义声明）外，其他所有声明都必须使用关键字extern，并且只有在定义声明中才可以对该变量进行初始化。 注意：除非在 B 文件中也声明了该变量（通过使用extern），否则在一个文件中定义的外部变量不可以用于第二个文件。 一个外部变量声明本身只是使一个变量可能对其他文件可用。 具有内部链接的静态变量这种存储类的变量具有静态存储时期，文件作用域以及内部链接。通过使用存储类说明类static在所有函数外部进行定义（正如定义外部变量那样）来创建一个这样的变量： 123static int svil = 1; // 具有内部链接的静态变量int main(void)&#123; 可以在函数中使用存储类说明符extern来再次声明任何具有文件作用域的变量。这样的声明并不改变链接。 存储类说明符C 语言中有 5 个作为存储类说明符 (storage class specifier) 的关键字，它们是auto register static extern以及typedef。 typedef与内存存储无关，由于语法原因被归入此类。不可以在一个声明中使用一个以上存储类说明符，意味着不能将其他任一存储类说明符作为typedef的一部分。 存储类和函数函数也具有存储类。函数可以是外部的（默认情况下）或者静态的（ C 99增加了第三种可能性，即内联函数）。 外部函数可被其他文件中的函数调用，而静态函数只可以在定义它的文件中使用。 使用哪种存储类尽量使用 auto。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objectiv-C 学习笔记]]></title>
      <url>%2F2016%2F11%2F30%2FObjectiv-C-Program%2F</url>
      <content type="text"><![CDATA[虽然已经有了 Swift，但是还是有很多 Objective-C 的项目，这门语言还是有必要学一学。如果已经有 C 语言的基础，相信你能很快上手。OC 是完全兼容 C99 的，所以也会先回顾一下 C 语言的重要内容。 如果还完全不会用 Xcode 创建项目和文件，可以看看 Xcode 使用笔记 0 新司机上路 C 语言基础回顾布尔值Xcode 支持 C99 标准 1_BOOL a = true; 注意在 Objective-C 中，BOOL类型使用 8 位存储空间，如果不小心将一个大于 1 字节的整型值（比如short或int）付给一个BOOL变量，那么只有低位字节会用作BOOL值，如果该低位字节刚好为 0（比如说 8960，写成十六进制为0x2300），BOOL值将会被认作是 0 ，即 NO值，故不要混用数字和BOOL类型。 函数 如果变量是“与某块数据相关联的名称”，那么函数就是“与某块代码相关联的名称”。 发现代码中的重复，提取具有共通性的部分并将其用独立的函数处理，接着添加参数处理差异部分。 局部变量、帧和栈函数可以有很多局部变量，这些局部变量都保存在函数的帧 (frame) 中。 使用栈 (stack) 来描述帧在内存中存储的地点。执行函数时，函数的帧会在栈的顶部被创建出来。函数执行结束时，我们会说函数返回了。也就是说，其帧会退出栈，等待下一个调用它的函数继续执行。 全局变量与静态变量在函数外声明的变量称为全局变量。复杂的程序会涉及大量的文件，包含不同的函数。这些文件中的代码都能访问全局变量。在不同的文件中共享变量不一定都是好事，有时候会引起很严重的混淆问题。 为此，C 语言引入了静态变量 (static variable)概念。只有那些声明了静态变量的文件才可以访问静态变量。详见下一小节。 存储类、链接和内存管理C 语言中有 5 个作为存储类说明符的关键字，它们是auto register static extern以及typedef。 typedef与内存存储无关，由于语法原因被归入此类。不可以在一个声明中使用一个以上存储类说明符，意味着不能将其他任一存储类说明符作为typedef的一部分。 C 使用作用域、链接和存储时期来定义 5 种存储类，见下表： 存储类 存储时期 作用域 链接 声明方式 自动 自动 代码块 空 代码块内 寄存器 自动 代码块 空 代码块内，使用 关键字 register 空链接的静态 静态 代码块 空 代码块内，使用关键字 static 具有外部链接的静态 静态 文件 外部 所有函数之外 具有内部链接的静态 静态 文件 内部 所有函数之外，使用关键字 static 详见：C 语言存储类详解 指针通过*运算符，可以访问保存在某个地址中的数据。 不同数据类型的大小sizeof()会返回一个类型为size_t的数，与之对应的格式是%zu，较少用到。示例： 1234567891011121314#import &lt;stdio.h&gt;int main(int argc, const char * argv[])&#123; int i = 17; int *addressOfI = &amp;i; printf("i stores its value at %p\n", addressOfI); *addressOfI = 89; printf("Now i is %d \n", i); printf("An int is %zu bytes\n", sizeof(int)); printf("A pointer is %zu bytes\n", sizeof(int *)); return 0;&#125; 运行程序，如果指针长度是 4 个字节，那么该程序就是在 32 位环境下运行，8——64 位环境。 NULLNULL就是 0（地址也是数字）。在if的条件中，很方便判断指针是否为空： 1234567float *myPointer;...// myPointer 指针是否为空？if(myPointer)&#123; ...// myPointer 非空&#125; 或者用较简洁的三元运算符 123// 如果 measureGravityPtr 是空值，则计算重力值float actualGravity = measureGravityPtr? *measuredGravityPtr : estimatedGravity(planetRadius); 通过引用传递通过一个实例来学习，其中调用modf()函数并传入一个double类型数，可以得到该浮点数的整数部分和小数部分。 12345678910111213141516171819202122#import &lt;stdio.h&gt;#import &lt;math.h&gt;int main(int argc, const char * argv[])&#123; double pi = 3.14; double integerPart; double fractionPart; // 将 integerPart 的地址作为实参传入 fractionPart = modf(pi, &amp;integerPart); // 获取 integer 地址上的值 printf("integerPart = %.0f, fractionPart = %.2f\n", integerPart, fractionPart); return 0;&#125;// 运行结果// integerPart = 3, fractionPart = 0.14// Program ended with exit code: 0 调用函数时传入某个地址，然后由函数将数据传入该地址指向的内存，这种参数传入方式称为通过引用传递 (pass-by-refrence)。 以下是一个很实用，很简单的通过引用传递参数的例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 将公制单位米转换成非公制单位的英尺和英寸，// 需要读取一个浮点数，返回两个浮点数。// 调用函数时，要为 meters 传入相应的值。// 此外，还要提供两个地址，用于保存 feet 和 inches。#import &lt;stdio.h&gt;#import &lt;math.h&gt;void metersToFeetAndInches(double meters, unsigned int *ftPtr, double *inPtr)&#123; // 这个函数假定 meters 的值是非负数 // 将 meters 变量转化为 feet 的值，类型为浮点数。 double rawFeet = meters * 3.281; // 计算类型为无符号整型 feet 变量的值 unsigned int feet = (unsigned int)floor(rawFeet); // 将 feet 变量的值储存在提供的地址里 printf("Storing %u to the address %p \n", feet, ftPtr); *ftPtr = feet; // 计算英寸 double fractionalFoot = rawFeet - feet; double inches = fractionalFoot * 12.0; // 将 inches 变量的值储存在传入的地址里 printf("Storing %.2f to the address %p \n", inches, inPtr); *inPtr = inches;&#125;int main(int argc, const char * argv[])&#123; double meters = 3.0; unsigned int feet; double inches; metersToFeetAndInches(meters, &amp;feet, &amp;inches); printf("%.1f meters is equal to %d feet and %.1f inches.\n", meters, feet, inches); return 0;&#125;// 运行结果//Storing 9 to the address 0x7fff5fbff7b4//Storing 10.12 to the address 0x7fff5fbff7a8//3.0 meters is equal to 9 feet and 10.1 inches. Objective-C 基础学习自《Objective-C 编程》第二版，《Objective-C 基础教程》第二版，iTunes 上 Stanford iOS7 的视频。 类和方法初体验方法和消息1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // date 类方法 class method // 类方法会创建类的实例 // 并创建实例变量 NSDate *now = [NSDate date]; NSLog(@"This NSDate object lives at %p", now); NSLog(@"The date is %@", now); // timeIntervalSince1970 实例方法 instance method // 提供实例中实例变量的信息，或是对实例变量进行操作 double seconds = [now timeIntervalSince1970]; NSLog(@"It has been %f seconds since the start og 1970.", seconds); // 方法带实参时，冒号时构成方法名的一个重要部分。 // 所以不存在 dateByAddingTimeInterval 方法 // 只有 dateByAdding-TimeInterval 方法 NSDate *later = [now dateByAddingTimeInterval:100000]; NSLog(@"In 100,000 seconds it will be %@.", later); NSCalendar *cal = [NSCalendar currentCalendar]; NSLog(@"My calendar is %@", [cal calendarIdentifier]); // 获取更多关于 NSDate 的信息 unsigned long day = [cal ordinalityOfUnit:NSCalendarUnitDay inUnit:NSCalendarUnitMonth forDate:now]; NSLog(@"This is day %lu of the month", day); // 消息的嵌套 double secondsNest = [[NSDate date] timeIntervalSince1970]; NSLog(@"It has been %f seconds since the start of 1970", secondsNest); // 练习：获取计算机的相关信息 // currentHost 类方法 NSHost *host = [NSHost currentHost]; // localizedName 实例方法 NSString *hostString = [host localizedName]; NSLog(@"This computer's name is %@.\n", hostString); &#125; return 0;&#125; alloc 和 init唯一必须以嵌套的形式连续发送的消息是alloc和init。 1234// NSDate *now = [NSDate date];NSDate *now = [[NSDate alloc] init];// 两种方法等价，使用 date 方法可以用最少的代码获取一个 NSDate 实例// 称这种方法为便利方法 convenience method 向 nil 发送信息nil是不指向任何对象的指针，多数面向对象的语言不允许向nil发送消息，但是在 Objective-C 中，可以向nil中发送消息，什么事情也不会发生。 重点1:如果程序向某个对象发送了消息，但是没有得到预期的结果，请检查消息接收方是否为nil。 重点2:向nil发送消息，得到的返回值没有意义。 idid 是可以指向任意类型对象的指针id 已经隐含了星号的作用。 获取从出生到当前时刻的时间间隔（单位：秒） 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSDateComponents *comps = [[NSDateComponents alloc] init]; [comps setYear:1997]; [comps setMonth:5]; [comps setDay:1]; [comps setHour:10]; [comps setMinute:10]; [comps setSecond:0]; NSCalendar *g = [[NSCalendar alloc] initWithCalendarIdentifier: NSCalendarIdentifierGregorian]; NSDate *dateOfBirth = [g dateFromComponents:comps]; NSDate *now = [NSDate date]; double secondsSinceEarlierDate = [now timeIntervalSinceDate:dateOfBirth]; NSLog(@"I have been living for %f seconds", secondsSinceEarlierDate); &#125; return 0;&#125; 对象和内存内存管理栈是由有序的帧构成的。函数的帧在函数结束后会自动释放。而堆里的对象不会自动释放。管理堆很重要，因为程序占用的堆大小是有限的。而每个对象被创建后都会占用一顶的堆内存。如果系统内存不足，Mac 应用的运行效果就会变差，而 iOS 应用则会崩溃。因此，必须释放不需要的对象，将内存交还给系统，继续重新使用。 1234567NSDate *currentTime = [NSDate date];NSLog(@"currentTime's value is %p", currentTime);sleep(2);currentTime = [NSDate date];NSLog(@"currentTime's value is now %p", currentTime); ARC第一个NSDate实例对象怎么样了？ 我们已经丢失了这个对象以及其包含的信息。因为我们丢失了指向该对象的指针，即使它仍然在堆上，我们也再不能获得这个对象的信息。如果要保留第一个 NSDate实例，需要在currentTime指向第一个实例时，创建新指针从currentTime那里获取第一个实例对象的地址，此时第一个实例对象的引用数为 2（该实例被 2 个指针所指向）。 将指向实例对象的指针设置为nil，实例对象就会失去一个引用，如果开启了 ARC，当一个实例对象的引用数为 0 时，就会自动销毁该实例对象，释放内存。 ARC automatic reference counting 自动引用计数 如果指针变量被销毁，它所指向的对象会失去一个引用。当某个对象的实例变量指向其他对象时，事情会变得更复杂—— todo NSString创建 NSString 实例1NSString *lament = @"Why me?"; 创建动态字符串，字符串的内容要等到程序运行时才能知道，可以使用stringWithFormat:类方法来创建动态字符串： 1NSString *datastring = [NSString stringWithFormat:@"The date is %@", now]; 使用官方文档打开 Xcode 的 “Help -&gt; Documentation and API Reference”,或者用快捷键 “Command + Shift + 0” ，搜索想了解的资料，注意语言的切换，可以先在顶部的搜索框输入某个类，再用 “Command + f” 在页面内搜索这个类的某个方法。 NSArray创建数组和遍历123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // 创建 3 个 NSDate 对象 NSDate *now = [NSDate date]; NSDate *tomorrow = [now dateByAddingTimeInterval:24.0 * 60.0 * 60.0]; NSDate *yesterday = [now dateByAddingTimeInterval:-24.0 * 60.0 * 60.0]; // 创建 1 个数组包含这 3 个对象 NSArray *dateList = @[now, tomorrow, yesterday]; // NSArray 实例一旦创建就无法改变， // 无法添加删除数组中的元素，也无法改变它们的位置 // 输出其中的两个对象 NSLog(@"The first date is %@", dateList[0]); NSLog(@"The third date is %@", dateList[2]); // 用 count 方法获取 dateList 指向的 NSArray // 对象的元素个数 NSLog(@"There are %lu dates", [dateList count]); // 遍历数组 NSUInteger dateCount = [dateList count]; for(int i = 0; i &lt; dateCount; i++) &#123; NSData *d = dateList[i]; NSLog(@"Here is a date: %@", d); &#125; // 快速枚举 for(NSDate *d in dateList) &#123; NSLog(@"Here is a date: %@", d); &#125; &#125; return 0;&#125; 可变数组 NSMutableArray1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // 创建 3 个 NSDate 对象 NSDate *now = [NSDate date]; NSDate *tomorrow = [now dateByAddingTimeInterval:24.0 * 60.0 * 60.0]; NSDate *yesterday = [now dateByAddingTimeInterval:-24.0 * 60.0 * 60.0]; // 创建空数组 NSMutableArray *dateList = [NSMutableArray array]; // 将 2 个 NSDate 对象加入新创建的数组 [dateList addObject:now]; [dateList addObject:tomorrow]; // 将 yesterday 指针插入到数组的起始位置 [dateList insertObject:yesterday atIndex:0]; // 快速枚举 for(NSDate *d in dateList) &#123; NSLog(@"Here is a date: %@", d); &#125; // 删除 yesterday 指针 [dateList removeObjectAtIndex:0]; NSLog(@"Now the first date is %@", dateList[0]); &#125; return 0;&#125; 旧式数组方法1NSArray *dateList = [NSArray arrayWithObjects:now, tomorrow, yesterday, nil]; 结束处的nil 告诉方法停止运行，所以，这个NSDate数列拥有三个指针对象。如果没有 练习购物清单123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; NSString *bread= @"Loaf of bread"; NSString *milk = @"Container of milk"; NSString *butter = @"Stick of butter"; NSMutableArray *shoppingList = [NSMutableArray array]; [shoppingList addObject:bread]; [shoppingList addObject:milk]; [shoppingList addObject:butter]; for(NSString *s in shoppingList) &#123; NSLog(@"Don't forget to buy %@", s); &#125; &#125; return 0;&#125; 里程碑 1：学会从问题出发查找 OC 文档在专有名词和常见名词表单中找到含”aa”的专有名词（即首字母大写）。 在给出的程序基础上，思考：如何判断首字母是否是大写，在NSString的界面搜索capital，发现没有相关方法，于是搜索index，想着应该有用index获取某个字符的方法，搜索得 1- (unichar)characterAtIndex:(NSUInteger)index; 于是将获取的字符与&#39;A&#39; 和&#39;Z&#39;比较一下就好了。 读入文件并将数据保存在字符串中的方法12345// 读入文件并将数据保存在字符串中// 没有处理可能发生的错误NSString *nameString = [NSString stringWithContentsOfFile: @"/usr/share/dict/words" encoding:NSUTF8StringEncoding error:NULL]; 然后贴一下完整的源码，打开的文件是在任意一台有 Mac OS 系统的人都有的文件，不必修改任何代码就可以运行。 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // 读入文件并将数据保存在字符串中 // 没有处理可能发生的错误 NSString *nameString = [NSString stringWithContentsOfFile: @"/usr/share/dict/words" encoding:NSUTF8StringEncoding error:NULL]; // 将所得字符串按"\n"进行分割，并保存在数组中 NSArray *names = [nameString componentsSeparatedByString:@"\n"]; // 枚举数组，一次处理一个字符串 for (NSString *n in names) &#123; // 查找字符串 "aa"（忽略大小写） NSRange r = [n rangeOfString:@"AA" options:NSCaseInsensitiveSearch]; // 是否找到 if (r.location != NSNotFound) &#123; // 获取每个单词的第一个字符 unichar firstChar = [n characterAtIndex:0]; if (firstChar &gt;= 'A' &amp;&amp; firstChar &lt;= 'Z') &#123; NSLog(@"%@", n); &#125; &#125; &#125; &#125; return 0;&#125; 里程碑2：第一个自定义类快捷键“Ctrl-Command-上箭头”，在 .m 文件及其对应的 .h 文件中切换。 在头文件中声明方法12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;@interface BNRPerson : NSObject&#123; // Step 0: BNRPerson 拥有两个实例变量 float _heightInMeters; int _weightInKilos;&#125;// Step1: 在花括号外声明 5 个实例方法- (float)heightInMeters;- (void)setHeightInMeters:(float)h;- (int)weightInKilos;- (void)setWeightInKilos:(int)w;// BNRPerson 类拥有计算 Body Mass Index 方法- (float)bodyMassIndex;@end 在 .m 文件中实现方法12345678910111213141516171819202122232425262728293031#import &lt;Foundation/Foundation.h&gt;#import "BNRPerson.h"@implementation BNRPerson- (float)heightInMeters&#123; return _heightInMeters;&#125;- (void)setHeightInMeters:(float)h&#123; _heightInMeters = h;&#125;- (int)weightInKilos&#123; return _weightInKilos;&#125;- (void)setWeightInKilos:(int)w&#123; _weightInKilos = w;&#125;- (float)bodyMassIndex&#123; return _weightInKilos / (_heightInMeters *_heightInMeters);&#125;@end 在 main()添加使用 BNRPerson 类的代码首先记得在 main.m 中导入头文件，当你打出 BNR… 还没有自动补全的提示，那么很可能是忘记了导入头文件。 1#import "BNRPerson.h" TBC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode 使用笔记 0 新司机上路]]></title>
      <url>%2F2016%2F11%2F29%2Fusing-Xcode-0%2F</url>
      <content type="text"><![CDATA[Xcode 是苹果家官方 IDE，颜值非常高，界面也挺复杂，偶然在学校图书馆发现一本 《Xcode 江湖录》，结合自己学习 OC 和以往使用 Xcode 的一些经验写写 Xcode 的使用笔记。希望能对看到这个系列文章的同学有所帮助，当然包括记性不好的我自己：）如有谬误，请不吝赐教。 使用的版本是 8.1。 欢迎界面一般第一次打开 Xcode 都会有一个如下的欢迎界面。 界面右端列举了最近使用过的项目，方便快速打开常用项目。如果要打开的项目不在这个列表中，可以点击列表下面的 “Open another project…”。 如果不想再看到这个欢迎界面，可以取消勾选左下方的 “Show this window when Xcode lauches”。不建议取消勾选。但是如果你取消勾选了之后又想要打开 Xcode 的欢迎界面，那么依次选择菜单栏上的 “Window -&gt; Welcome to Xcode” 即可，或者直接使用⌘+⇧+1(“Command + Shift + 1”) 快捷键。 Playground就是一个让你玩 Swift 的地方，能够即时得到你的代码结果，不过功能有限。 创建项目填入相关信息及说明单击 “Create a new Xcode project” ，弹出一个项目模板选择窗口如下图，由于版本问题，你看到的窗口可能和我不一样，但是基本上都非常类似。 选择 “OS X” -&gt; “Application” -&gt; “Command Line Tool”。然后填入： 项目名称（Product Name） 组织名称（Organization），嗯，你可以填入你的公司名称，哪怕公司现在只有你一个光杆司令：） 组织标识符（Organization Identifier）。必须是 DNS 的逆序，然后是你的名字（比如我的是 com.vectorlu.Victoria)，这个东西是你将 App 发布到 App Store 之后，App Store 用来标志你身份的东西，所以必须是独一无二的。由于 DNS 在网络上往往是独一无二的，所以这种方式是一种普遍的标志方式，Android 也是这样的。当然，你现在可能没有 Organization Identifier ，可以填入 com.example.yourname，想了解更权威的说明，可以戳这里：苹果官方的说明。 有 4 种语言可以选择，选择你熟悉的语言就好，笔者同时在学习 Objective-C，如果你在学习 C 语言，选择 OC 或 C 都没关系，因为 OC 完全兼容 C 语言。不过 OC 的后缀名是.m，代码的模版和 C 语言不同。 不推荐数字作为项目名称的首字母，也不推荐用特殊字符来命名项目名称和组织标识符。因为如果这样做，下面的包标识符 (Bundle Identifier) 会用-来代替不符合规范的字符，可能给上传应用带来麻烦。 组织标识符和包标识符都是用来唯一确定应用身份的标识符，已经创建后最好不要修改，以免带来一些不必要的麻烦。 在哪里写代码？初次创建完项目后，新司机可能会被 Xcode 复杂的界面吓到，而且如果没有汉化，英语不好的新司机更是感觉很头大。无论如何，Xcode 的颜值还是挺高(((o(*ﾟ▽ﾟ*)o)))。要如何同这个高颜值的 IDE 玩耍呢？ 这个窗口有很多信息，但实际上不需要这么多，简化一下。右上角我框起来的地方有三个按钮，用来隐藏或显示窗口中的不同区域。比如最右边的蓝色按钮，表示右侧栏正在显示，点一下就变灰了，说明右侧栏被隐藏。 窗口右侧栏的信息暂时用不上，先隐藏。好了，现在窗口上左端是导航区 (Navigator Area)，右端是编辑区 (Editor Area)。点一下左侧的main.m就可以在右端的编辑区中开始编辑代码了，如果双击 Xcode 会打开一个新的窗口。快捷键 Command + r，或者单击左上角的类似于播放键的按钮，就可以运行程序了。 运行成功的标志，如果失败了就是 Failed 下图是 Xcode 的调试区域，可以查看代码运行的结果和一些出错信息。如果没有出现这个控制台窗口，那么依次点击 “View -&gt; Debug Area -&gt; Activate Console” 打开调试区域，或者直接使用快捷键 Command + Shift + c直接打开。 导入库在 Xcode 中，比如要使用readline()函数，需要先添加包含这个函数的库类，关于 readline类库。 在左端的项目导航中，点击顶层的项目 “HelloXcode”。在右端编辑区域中，点击 Build Phases 后展开 Link Binary With Library 的三角格式说明符。点击 + 按钮，如下图： 然后表单会展开，显示可用的代码库清单。使用搜索栏 search box 搜索 libreadline。表单中显示它时，选择并点击添加按钮。然后在代码中加上#import &lt;readline/readline.h&gt;就可以使用readline()函数了。 移除项目在 Finder 中删除找到项目所在的地方直接删除就好。但是这种方法会在 Xcode 中留下一些残余的缓存文件。不过一般没有什么影响。 在 Xcode 中彻底删除在屏幕最上方的菜单栏中点击 “Window -&gt; Projects”，选中刚刚删除的项目，然后点击右上角的 Delete 或者左下角的小齿轮，选择 “Remove from Projects” 选项，就可以清除这些缓存文件。 这次就说到这里，新司机萌，上路愉快：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C_Compiler_by_C]]></title>
      <url>%2F2016%2F11%2F28%2FC-Compiler-by-C%2F</url>
      <content type="text"><![CDATA[编译原理基础知识总结 CH1 编译概述TODO CH2 文法和语法的基础知识TODO:6 文法和语言的分类0 型文法（无限制文法）关键在于𝜷可以为空 1 型文法（上下文有关文法）1𝜶𝑨𝜷 → 𝜶𝑢𝜷 2型文法（上下文无关文法）CH3 词法分析与有穷自动机词法分析程序的功能对字符串表示的源程序从左到右进行扫描和分解，根据语言的词法规则识别出一个一个具有独立意义的单词符号。 单词符号及输出单词的形式词法分析程序的： 输入：字符串形式的源程序 输出：单词符号 or 单词符号表示的源程序 语言的单词符号 token语言中具有独立意义的最小语法单位，分为以下 5 种： 关键字if else while do 等 标识符,比如变量名、常量名、数组名、函数名等等 常数，比如 整型常数 125 实型常数 0.718 布尔型常数 TRUE 等等 运算符+ - * / &lt; 等等 界符, ; ( ) : 等等 一个程序语言的关键字、运算符和界符的个数是确定的，而对于标识符或常数的使用个数通常是不确定的。 词法分析程序输出单词的形式二元式： 1（单词种别，单词自身的值） 单词种别单词种别表示单词的种类，是语法分析需要的信息。 一个语言的单词符号如何划分种类、分成几个种类、怎样编码，取决于处理方便。通常让每种单词对应一个整数码，最大限度地把各个单词区别开。 关键字：全体视为一种，但一般一字一种（个数确定） 运算符：同关键字 界符：同关键字 标识符：统归为一种 常数：可按类型（整型、实型、布尔型等等），也可统归为一种，比如 1(+|-|ɛ)dd*(.dd*|ɛ)(e(+|-|ɛ)dd*|ɛ) 单词自身的值单词自身的值是编译中其他阶段所需要的信息。 用以下方法确定其值： 如果一个种别只含一个单词符号，那么对于这个单词符号，种别编码完全代表其自身的值。 如果一个种别又多个单词符号，那么对于它的每个单词符号，除了给出种别编码之外，还应 给出单词符号的自身值，以便把同一种类的单词区分开来。 标识符的自身值：标识符自身的字符串 常数自身值：常数本身的二进制数值 用指向某类表格中一个特定项目的指针值来区分同类中不同单词 标识符：在符号表的入口指针作为它自身的值 常数：在常数表的入口指针作为自身值 假设关键字、运算符和界符都是一符一种，标识符自身的值用自身的字符串表示，常数自身的值用标准二进制形式表示，则程序段if (a &gt; 1) b = 100;在经词法分析程序扫描后，它所输出的单词符号串是： 二元式 表示的意义 (2, ) 基本字if (29, ) 左括号( (10, ‘a’) 标识符a (11, ‘1’的二进制) 常数1 (30, ) 右括号) (10, ‘b’) 标识符b (17, ) 赋值号= (11, ‘100’的二进制) 常数100 (26, ) 分号; 其中，假设标识符种类编码为整数 10，常数的种类编码为整数 11，基本字if种类编码为 2，赋值号种类编码为…… 语言单词符号的两种定义方式 正规文法 正规式 TODO CH4 语法分析文法的左递归性和回溯的消除在自上而下分析过程中，为了避免回溯，即要求描述语言的文法是 LL(1) 文法。 LL(1) 文法的判断条件1设 𝜶 TBC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去掉 mac 终端下长长的电脑名和用户名]]></title>
      <url>%2F2016%2F11%2F27%2Fremove-long-pc-user-name%2F</url>
      <content type="text"><![CDATA[在 Linux 或 macOS 下用 bash 的时候，当然如果你是 zsh 用户，一般不会有这种困扰——终端每一行前面有好长的一串——“本机名 当前路径 用户名”，再是表示等待输入指令的$。在 bash 下要如何去掉这些冗长的信息呢？ 在终端下进入/etc目录，这个目录是类 Unix 系统存放一些零碎的系统配置文件的文件夹。 用文本编辑器打开bashrc，我习惯用 Atom 。 1$ atom /etc/bashrc PS1: 控制默认命令行提示符的格式。在终端下用echo $PS1命令显示当前提示符设置。 Richard BlomLinux 命令行与 Shell 脚本编程大全第2版 所以，修改bashrc文件中的PS1的值就可以了 ‘\h’ 指的是主机‘\W’ 指的是当前工作目录‘\u’ 指的是当前用户 修改成你喜欢的样子就好了，一般保留\W。该方法来自这个博客中去掉（隐藏）mac终端前面的计算机名 ta 的博客中 20161028的那一篇。那篇博文的 URL 有问题，黏贴过来之后无法正常访问 Orz 。 效果如下 感谢 liuxiaojia 这位朋友的提醒。 同时，诚恳建议 Hexo 博客的文件名中不要包涵特殊的中文符号，比如中文括号，给正确复制博客网址带来了莫大的困难 Orz 。建议新建 Hexo 博客可以全部用英文，Hexo 生成博客的 URL 完全根据文件名生成，中文在复制过程中容易乱码，中文符号也会带来一些麻烦 Orz 。参考博客的 URL 就是因为包含中文括号，所以在复制 URL 后无法访问到正确的地址。 博客的题目title字段就无所谓了，对中文及相关符号很友好。Hexo 会自动设置为文件名，但是可以手动修改，不会影响 URL，设置成你喜欢的中文名就好了。 如下图，文件名用英文，生成 md 文件后把题目手动改成中文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo_4_NexT_Pisces_主题配置细节]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-4-theme-NexT-Pisces-details%2F</url>
      <content type="text"><![CDATA[待完成 Orz 安装]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo_3_写作与更新的细节]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-3-writing-update-blog%2F</url>
      <content type="text"><![CDATA[基本操作就是根据Hexo官方文档NexT官方文档来配置一些细节，在这里用图文记录一下具体过程和比较常用的命令。 写作创建新文章1$ hexo new [layout] &lt;title&gt; 创建了新文章之后打开，会在文章开头看到类似以下内容的东西。 123456789---title: 使用 Hexo 搭建博客的细节配置 1date: 2016-11-26 00:03:44categories:- KITtags:- blog- hexo--- 这个部分是用来指定该文章的各种变量哒： 参数 描述 默认值 layout 布局 title title date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页) permalink 覆盖文章网址 － 只有文章支持分类和标签，page 不支持，标签没有顺序和层次。 引用md 本身有自己的引用语法 这是第一行引用这是第二行引用引用方式非常简单，但是引用的样式比较单一，如果要显示引用源的相关信息就力不从心了。 以下来自标签插件，摘录到本地方便查阅。 引用网络上的文章123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125; 效果： Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 引用 Twitter123&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http://devdocs.io&#123;% endblockquote %&#125; NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用书上的句子123&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 没有提供参数，则只输出普通的 blockquote123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 创建新页面比如新建about页面 1hexo new page about 服务器hexo-server安装1$ npm install hexo-server --save 启动安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。1$ hexo server 或 1$ hexo s 更改端口想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000 生成文件hexo generate 或 hexo g 完成后部署执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。 12$ hexo generate --deploy$ hexo deploy --generate 部署详见 多语种支持在站点配置文件 _config.yml 中修改 new_post_name 和 permalink 参数，如下： 12new_post_name: :lang/:title.mdpermalink: :lang/:title/ 建立新文章时，文章会被存储到： 12$ hexo new "Hello World" --lang tw# =&gt; source/_posts/tw/Hello-World.md 而网址会是http://localhost:4000/tw/hello-world/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-2-用 Coding Pages 部署 Hexo 博客]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-2-coding-pages%2F</url>
      <content type="text"><![CDATA[待完成 Orz]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo-1-用 Github Pages 部署 Hexo 博客]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-1-github-pages%2F</url>
      <content type="text"><![CDATA[安装好了 Hexo，下一步就是：将自己的博客放到网上，让每个人都能访问。 介绍一下如何用 Github 的 Pages 服务来支持静态博客。如果你对 Git 还不熟悉，那么建议你先阅读一下（不阅读也没有关系，因为 Hexo 不需要太多 Git 的知识）：廖雪峰的Git教程 Step-0-注册Github在 Github官网 中 sign up 就好了。 Step-1-管理远程仓库相关命令概览与说明其实用不到这么多 git 的知识，只是顺带介绍一下，可跳过。 1234567891011121314151617ssh-keygen -t rsa -C ("youremail@example.com")#创建ssh keygit remote add origin (repository address on github)#关联远程仓库git remote -help #用来查看帮助git push -u origin master#第一次推送本地内容到远程仓库要加 -u参数git push origin master#以后就可以直接推送内容了git clone (repository address on github)#将repository克隆到本地 添加远程仓库 SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 创建SSH Key在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C "youremail@example.com" 需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 用文本编辑器打开 id_rsa.pub ，比如atom（如果安装了atom），vi等 也可以用这样方法打开id_rsa文件如果没有安装atom，可以用vi打开$ vi id_rsa 登陆Github打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：点“Add Key”，你就应该看到已经添加的Key：以上两张图片来自廖雪峰的git教程 测试一下 1ssh -T git@github.com 可能会有警告，不过没关系，输入yes就好。 在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 添加 Repository首先，登陆GitHub，然后，在右上角找到一个加号，点击“ New repository”按钮，创建一个新的仓库，仓库名用username.github.io。比如我的用户名是VectorLu，那么新建的仓库名（Repository name）就是VectorLu.github.io。 下面的 Description 随便写就好了，比如写 My blog repository. 其他的都不用管，点下面的绿色按钮Create repository就好了。 Step-2-部署本地的 Hexo 博客到 Github还记得在 Hexo-0 中用 hexo init foldname 那个文件夹吗？进入文件夹，用文本编辑器打开_config.yml，我习惯用atom打开，或者用自带的vi打开也可以。 也许你没有atom，也不会用vim。那就在Finder中找到这个文件，双击，应该会默认用Xcode打开。 用command+f快捷键，或者直接在这个文件的最后（一般是放在最后）找到deploy字段。修改成如下样式，注意把所有 VectorLu 换成你的 Github 用户名。 12345deploy: type: git repo: github: git@github.com:VectorLu/VectorLu.github.io.git branch: master 保存，进入终端。 1234$ npm install hexo-deployer-git --save # 安装相关组件$ hexo clean$ hexo g$ hexo d 应该一会就部署好了，在浏览器中输入username.github.io就可以访问你的博客了。如果没有刷出来，可能是网络问题，多等一会就可以刷出来了。 Step-3-绑定个人域名（非必需）有很多网站出售域名，比如万网。 //TODO: !!!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo_0_Mac 下搭建自己的博客图文详解]]></title>
      <url>%2F2016%2F11%2F26%2FHexo-0-mac-build-blog%2F</url>
      <content type="text"><![CDATA[Hexo 安装与建站分享一下 2016-11 在 Mac 下使用 Hexo3 &amp; github &amp; coding &amp; 万网 搭建博客的经验、技巧、注意事项。 用 Hexo 建站命令行概览注意！HexoBlogFolder这个文件名仅作为提示，选择任何你喜欢的文件名就好，以后这个文件夹中包含所有部署博客的相关文件，你也会在这个文件夹里存放你的思想结晶博客。 12345$ hexo init HexoBlogFolder$ cd HexoBlogFolder$ npm install$ hexo g # 等于 hexo generate$ hexo s # 等于 hexo server Hexo 安装安装 Hexo 时常容易出问题，原因一般是没有sudo授权。以前装过 Hexo，感觉麻烦不少，老是报错，但是这次（20161124），正好在 Hexo 重大更新到 Hexo3 之后，安装过程还比较顺利。需要注意的是：在 macOS 和 Linux 下 Hexo 安装时需要root权限，官方文档上给出的命令行没有用sudo实在有点坑 Orz。不过官方文档还是得看看，毕竟是最权威的资料，虽然有时候不够详细。 Step0-Git 安装首先需要有Git，如果已经安装 Xcode ，那么Git应该已经安装好了。因为 Hexo 需要用到 Xcode，所以在 AppStore 中下载安装就好了。如果不确定mac上是否有Git，可以在命令行中输入git --version查看。 如果已经安装，会显示出Git的版本。 如果没有安装，可以用多种方法安装，比如安装程序、Homebrew 安装。 Step0-Node.js 安装个人认为最好是用 Node.js 的官网安装包直接安装。一直确定就好了。 Step1-Hexo 安装官网上给出的命令行在 mac 上应该不能成功安装 Hexo $ npm install -g hexo-cli 需要使用： 1$ sudo npm install -g hexo-cli 没有什么 error 应该就没问题了。 Step2-Hexo 建站用终端cd到你喜欢的位置，比如cd Document然后执行下列命令，Hexo 会在~/Document/下新建所需文件 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 比如我就在~下新建了myBlog文件夹 123~ $ hexo init myBlog$ cd myBlog$ npm install Hexo 就安装好了，再执行 12$ hexo generate$ hexo server 上述命令也可以写作 12$ hexo g$ hexo s 就可以生成博客所需的文件，并启动本地服务器。 打开本地浏览器，在地址栏输入 localhost:4000，如下图，就能看到 Hexo 的 Hello World 界面。当然你的界面和我的还不一样，不过别着急，你马上就可以配置自己的个性界面了：） 安装主题 NexT逛了一圈 Hexo 的主题，每种主题都有各自的惊艳之处和不足之点。也打算自己写个主题，但是看了一下日程表，大概一年内都没有时间学习开发，关键是之后的文档支持和维护，都有点麻烦。 最后就选择了 NexT 的 Pisces。 在终端下进入之前用 Hexo 初始化的文件夹，比如我的是 myBlog，cd myBlog然后： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 进入myBlog文件夹，找到_config.yml（这个目录下的这个文件是站点配置文件），用 Xcode 或者文本编辑器打开，找到 theme 字段，修改成（注意冒号和 next 之间有一个空格。 1theme: next 进入theme文件夹，进入next文件夹，找到_config.yml（这个目录下的是NexT主题配置文件），找到 Schemes 字段，有三种主题可供选择，比如我个人比较喜欢 Pisces 1234# Schemes#scheme: Muse#scheme: Mistscheme: Pisces 在终端进入myBlog文件夹 123$ hexo clean$ hexo g$ hexo s 打开浏览器，输入http://localhost:4000/就会看到 Pisces 主题的界面了。 当然还有很多细节需要配置，我在后面的博文中也会陆续分享自己的经验。如果有好的建议，请不吝赐教。 Hexo官方文档NexT官方文档]]></content>
    </entry>

    
  
  
</search>
